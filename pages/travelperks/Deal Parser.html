<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Deal Parser – Enhanced Token Matching</title>
    <!-- Minimal Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" crossorigin="anonymous" />
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" crossorigin="anonymous" />
    <style>
        .icon-btn {
            cursor: pointer;
            margin: 0 5px;
        }

        .icon-btn:hover {
            color: #333;
        }

        th.sortable {
            cursor: pointer;
        }

        th.sortable:hover {
            color: #007bff;
        }

        table td small {
            color: #555;
        }

        .clickable {
            cursor: pointer;
            text-decoration: underline;
        }

        .match-detail {
            font-size: 0.85rem;
            padding: 2px 5px;
            border-radius: 3px;
            margin-right: 5px;
            display: inline-block;
        }

        .match-detail-success {
            background-color: #d4edda;
            color: #155724;
        }

        .match-detail-warning {
            background-color: #fff3cd;
            color: #856404;
        }

        .match-detail-danger {
            background-color: #f8d7da;
            color: #721c24;
        }

        .match-detail-info {
            background-color: #d1ecf1;
            color: #0c5460;
        }

        .highlight-match {
            background-color: #d4edda;
            padding: 0 2px;
            border-radius: 2px;
        }

        .highlight-mismatch {
            background-color: #f8d7da;
            padding: 0 2px;
            border-radius: 2px;
        }

        .text-comparison {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }

        .deal-title {
            font-weight: bold;
            color: #333;
        }

        .best-candidate-preview {
            font-size: 0.85rem;
            color: #666;
            max-width: 250px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .badge.score-breakdown {
            font-weight: normal;
            font-size: 85%;
        }

        .score-breakdown {
            font-size: 0.8rem;
            padding: 3px 6px;
            margin-left: 5px;
        }

        #matchSummary, #debugInfo {
            font-size: 0.9rem;
        }

        .small-text {
            font-size: 0.85rem;
        }
    </style>
</head>
<body>
    <div class="container my-4">
        <h1 class="mb-3">Deal Parser (Enhanced Token Matching)</h1>
        <!-- User-adjustable thresholds -->
        <div class="mb-3 row">
            <div class="col-md-3">
                <label for="minScoreThreshold" class="form-label">Minimum Match Score Threshold:</label>
                <input type="number" id="minScoreThreshold" class="form-control" value="3" min="0" step="0.5">
            </div>
            <div class="col-md-3">
                <label for="fuzzyMatchThreshold" class="form-label">Text Similarity Threshold (%):</label>
                <input type="number" id="fuzzyMatchThreshold" class="form-control" value="50" min="0" max="100">
            </div>
            <div class="col-md-3">
                <label for="dateRangeThreshold" class="form-label">Date Range Tolerance (days):</label>
                <input type="number" id="dateRangeThreshold" class="form-control" value="3" min="0" max="14">
            </div>
            <div class="col-md-3">
                <label for="monetaryMatchType" class="form-label">Monetary Match Type:</label>
                <select id="monetaryMatchType" class="form-control">
                    <option value="exact">Exact Match</option>
                    <option value="flexible" selected>Flexible Match</option>
                    <option value="partial">Partial Match</option>
                </select>
            </div>
        </div>

        <div class="mb-3">
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" id="requireExpiry" checked>
                <label class="form-check-label" for="requireExpiry">Require expiry date matching</label>
            </div>
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" id="requireMonetary" checked>
                <label class="form-check-label" for="requireMonetary">Require monetary value matching</label>
            </div>
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" id="enableFuzzyMatching" checked>
                <label class="form-check-label" for="enableFuzzyMatching">Enable fuzzy text matching</label>
            </div>
        </div>

        <div class="alert alert-info" role="alert">
            <h5>Match Algorithm Explanation</h5>
            <ul class="mb-0">
                <li>Supplier match is required and adds +10 points</li>
                <li>Monetary tokens (like "$600" or "5%") are processed based on selected matching type:
                    <ul>
                        <li>Exact: Values must match exactly</li>
                        <li>Flexible: Values can appear in different formats ($600 = 600 USD)</li>
                        <li>Partial: At least some monetary values must match</li>
                    </ul>
                </li>
                <li>Expiry date matching within the selected day range adds +10 points</li>
                <li>Fuzzy text matching compares overall text similarity</li>
                <li>Deal-specific keywords (obc, upgrade, etc.) earn bonus points</li>
                <li>You can adjust all thresholds to fine-tune matching sensitivity</li>
            </ul>
        </div>

        <div class="row">
            <!-- HQ deals input -->
            <div class="col-md-6 mb-3">
                <label for="hqDealsInput" class="form-label">HQ Deals (Raw Text):</label>
                <textarea id="hqDealsInput" class="form-control" rows="10">c Cruise Offers v Carnival: d Great Rates Sale (PB4): Ends 2/28/2025 d Pack & Go Sale (PUG): Ends today! d More=Merrier Sale-Save up to $125 per room + $25 NRD (PHY): 2/24-2/28/2025 d Onboard Credit Sale-Up to $50 OBC (OS5): Ends 2/28/2025 d 72 Hour Sale-Great Guarantee Rates (P3P): 2/26-2/28/2025</textarea>
            </div>
            <!-- Site deals JSON input -->
            <div class="col-md-6 mb-3">
                <label for="siteDealsInput" class="form-label">Site Deals JSON:</label>
                <textarea id="siteDealsInput" class="form-control" rows="10">[ { "id": 456, "enabled": 1, "enabledForSite": 1, "postDate": "2024-12-01 08:00:00", "expiryDate": "2025-02-02 00:00:00", "title": "Upgrade & Pre or Post Hotel Night", "field_shopOverline_cmsuxrfz": "Crystal Cruises", "field_shopListing_gxrjxnpo": "How about an upgrade plus a complimentary hotel night for your luxury getaway? Elevate your travel experience with an upgrade and enjoy a hotel night on us." }, { "id": 789, "enabled": 1, "enabledForSite": 1, "postDate": "2025-01-01 08:00:00", "expiryDate": "2025-02-01 00:00:00", "title": "EXCLUSIVE: Up To 2 Bonus Nights Specialty Dining", "field_shopOverline_cmsuxrfz": "Norwegian Cruise Line", "field_shopListing_gxrjxnpo": "Enjoy two specialty dining nights for balcony guests and one for oceanview and insider.", "dealCategory": [94, 39542], "status": "live" }, { "id": 1011, "enabled": 1, "enabledForSite": 1, "postDate": "2025-01-15 08:00:00", "expiryDate": "2025-02-28 00:00:00", "title": "EXCLUSIVE: Enjoy Up To $600 Onboard Credit with Silversea!", "field_shopOverline_cmsuxrfz": "Silversea", "field_shopListing_gxrjxnpo": "Set sail with Silversea and snag your $600 onboard credit, available through 2/28/2025." }, { "id": 2022, "enabled": 1, "enabledForSite": 1, "postDate": "2025-01-20 08:00:00", "expiryDate": "2025-02-28 00:00:00", "title": "Affordable Airfare to Europe", "field_shopOverline_cmsuxrfz": "Tauck Tours", "field_shopListing_gxrjxnpo": "Affordable Airfare to Europe: $990/Economy, $1,790/Premium, $3,890/Business + Tour Discover a flat price for European airfare, enhancing your travel adventure." }, { "id": 3033, "enabled": 1, "enabledForSite": 1, "postDate": "2025-01-25 08:00:00", "expiryDate": "2025-02-28 00:00:00", "title": "EXCLUSIVE: Enjoy Up To $200 Onboard Credit with Holland!", "field_shopOverline_cmsuxrfz": "Holland America Line", "field_shopListing_gxrjxnpo": "Treat yourself to extra perks; offer valid through 2/28/2025." }, { "id": 4044, "enabled": 1, "enabledForSite": 1, "postDate": "2025-01-30 08:00:00", "expiryDate": "2025-02-26 00:00:00", "title": "EXCLUSIVE: Unlock Up To $1800 in Savings with Princess!", "field_shopOverline_cmsuxrfz": "Princess", "field_shopListing_gxrjxnpo": "Join us for amazing savings available from 2/11 to 2/26/2025." }, { "id": 48047, "enabled": 1, "enabledForSite": 1, "postDate": "2025-01-06T01:00:00-08:00", "expiryDate": "2025-02-28T16:00:00-08:00", "title": "Unlock Amazing Savings with Carnival's Great Rates Sale!", "shopOverline": "Carnival Cruise Line", "field_shopListing_gxrjxnpo": "Enjoy onboard credit and special offers on Carnival's cruise deals!" } ]</textarea>
            </div>
        </div>
        <div class="row mb-3">
            <div class="col">
                <button id="parseButton" class="btn btn-primary">Parse & Classify</button>
                <button id="copyButton" class="btn btn-secondary">Copy New Deals (c/v/d/ed format)</button>
            </div>
        </div>

        <!-- Results Section -->
        <div id="resultsSection" class="d-none">
            <div class="row mb-4">
                <div class="col-md-6">
                    <div class="card">
                        <div class="card-header bg-success text-white">
                            <h3 class="mb-0">Match Summary</h3>
                        </div>
                        <div class="card-body">
                            <div id="matchSummary"></div>
                        </div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="card">
                        <div class="card-header bg-info text-white">
                            <h3 class="mb-0">Debug Information</h3>
                        </div>
                        <div class="card-body">
                            <div id="debugInfo"></div>
                        </div>
                    </div>
                </div>
            </div>

            <h3>Duplicates (Auto-matched)</h3>
            <div class="table-responsive mb-4">
                <table class="table table-striped" id="duplicatesTable">
                    <thead class="table-danger">
                        <tr>
                            <th class="sortable" data-sort="supplier">Supplier / HQ Deal</th>
                            <th class="sortable" data-sort="start">Start Date</th>
                            <th class="sortable" data-sort="end">End Date</th>
                            <th class="sortable" data-sort="score">Score</th>
                            <th>Match Details</th>
                            <th>Site Deal &amp; Expiry</th>
                            <th class="sortable" data-sort="status">Deal Status</th>
                            <th class="sortable" data-sort="exclusive">Exclusive?</th>
                            <th>Move</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            
            <h3>New Deals</h3>
            <div class="table-responsive mb-4">
                <table class="table table-striped" id="newDealsTable">
                    <thead class="table-dark">
                        <tr>
                            <th class="sortable" data-sort="supplier">Supplier / HQ Deal</th>
                            <th class="sortable" data-sort="start">Start Date</th>
                            <th class="sortable" data-sort="end">End Date</th>
                            <th class="sortable" data-sort="score">Score</th>
                            <th class="sortable" data-sort="exclusive">Exclusive?</th>
                            <th>Best Candidate</th>
                            <th>Match</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Modal for displaying candidate match details -->
    <div class="modal fade" id="matchModal" tabindex="-1" aria-labelledby="matchModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h1 class="modal-title fs-5" id="matchModalLabel">Candidate Match Details</h1>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div id="candidateDetails"></div>
                    <hr>
                    <div id="matchingAnalysis" class="mt-3"></div>
                </div>
                <div class="modal-footer">
                    <button id="modalMatchBtn" type="button" class="btn btn-primary">Match</button>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS and FontAwesome JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/js/all.min.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script>
        // =====================================
        // CONSTANTS AND CONFIGURATION
        // =====================================

        // Known suppliers list with aliases for better matching
        const KNOWN_SUPPLIERS = [
            { name: "Carnival", aliases: ["Carnival Cruise Line", "CCL"] },
            { name: "Cunard", aliases: [] },
            { name: "Crystal Cruises", aliases: ["Crystal"] },
            { name: "Norwegian", aliases: ["Norwegian Cruise Line", "NCL"] },
            { name: "Royal Caribbean", aliases: ["Royal Caribbean International", "RCI", "Royal"] },
            { name: "MSC Cruises", aliases: ["MSC"] },
            { name: "Princess", aliases: ["Princess Cruises"] },
            { name: "Celebrity", aliases: ["Celebrity Cruises"] },
            { name: "Holland", aliases: ["Holland America", "Holland America Line", "HAL"] },
            { name: "Silversea", aliases: ["Silversea Cruises"] },
            { name: "Tauck Tours", aliases: ["Tauck"] },
        ];

        // Enhanced synonym dictionary
        const SYNONYMS_DICT = {
            'obc': ['onboard', 'credit', 'onboardcredit', 'ob', 'on board', 'on-board'],
            'credit': ['onboard', 'credit', 'onboardcredit', 'cashback', 'cash back', 'cash-back', 'bonus'],
            'ppg': ['free', 'gratuities', 'freegratuities', 'tips', 'crew appreciation'],
            'gratuities': ['ppg', 'freegratuities', 'free', 'tips', 'complimentary', 'crew appreciation'],
            'exclusive': ['exclusive', 'only', 'special'],
            'dining': ['meals', 'restaurants', 'food', 'dining', 'specialtydining', 'specialty dining', 'bonusnights', 'bonus nights'],
            'sale': ['rates', 'savings', 'offer', 'deal', 'promotion', 'promo', 'discount'],
            'save': ['savings', 'discount', 'offer', 'deal', 'promotion'],
            'great': ['best', 'amazing', 'incredible', 'super', 'excellent'],
            'pack': ['go', 'travel', 'journey', 'trip'],
            'guarantee': ['guaranteed', 'promise', 'assurance'],
            'upgrade': ['elevate', 'enhanced', 'premium', 'improved'],
            'room': ['cabin', 'stateroom'],
            'merrier': ['more', 'extra', 'additional', 'bonus'],
            'rates': ['price', 'pricing', 'cost', 'fare', 'fares'],
            'hour': ['hr', 'hrs', 'hours'],
            'nrd': ['deposit', 'nonrefundable', 'non-refundable'],
        };

        // Key deal terms that get extra points
        const DEAL_KEYWORDS = new Set([
            "obc", "onboard", "credit", "ppg", "gratuities", "free", "cashback", "dinner", "spa", 
            "upgrade", "prepaid", "complimentary", "bonus", "exclusive", "special", "savings",
            "sale", "guarantee", "hotel", "rates", "perks", "extra", "discount", "offer", "promotion"
        ]);

        // Currency and unit symbols to extract monetary values
        const CURRENCY_SYMBOLS = ['$', '€', '£', '¥', 'usd', 'eur', 'gbp', 'jpy', 'cad', 'aud'];
        const VALUE_UNITS = ['%', 'percent', 'off', 'discount', 'savings', 'save'];

        // =====================================
        // DATA PROCESSING AND TOKENIZATION
        // =====================================

        // Function to normalize text for better matching
        function normalizeText(text) {
            return text.toLowerCase()
                .replace(/[^\w\s%$]/g, ' ')  // Replace non-alphanumeric except $ and % with spaces
                .replace(/\s+/g, ' ')        // Collapse multiple spaces
                .trim();
        }

        // Enhanced tokenization with synonyms expansion
        function tokenizeDealText(text) {
            if (!text) return [];
            
            // Normalize and split the text
            const normalizedText = normalizeText(text);
            let tokens = normalizedText.match(/[a-z0-9$%]+/g) || [];
            let expanded = new Set(tokens);
            
            // Add synonyms for each token
            tokens.forEach(token => {
                if (SYNONYMS_DICT[token]) {
                    SYNONYMS_DICT[token].forEach(syn => expanded.add(syn));
                }
            });
            
            return Array.from(expanded);
        }

        // Calculate text similarity using the Levenshtein distance algorithm
        function calculateStringSimilarity(str1, str2) {
            // Normalize inputs
            str1 = normalizeText(str1);
            str2 = normalizeText(str2);
            
            // If either string is empty, return 0
            if (!str1.length || !str2.length) return 0;
            
            // Simple case - exact match
            if (str1 === str2) return 100;
            
            // Calculate Levenshtein distance
            const matrix = Array(str1.length + 1).fill().map(() => Array(str2.length + 1).fill(0));
            
            for (let i = 0; i <= str1.length; i++) matrix[i][0] = i;
            for (let j = 0; j <= str2.length; j++) matrix[0][j] = j;
            
            for (let i = 1; i <= str1.length; i++) {
                for (let j = 1; j <= str2.length; j++) {
                    const cost = str1[i-1] === str2[j-1] ? 0 : 1;
                    matrix[i][j] = Math.min(
                        matrix[i-1][j] + 1,       // deletion
                        matrix[i][j-1] + 1,       // insertion
                        matrix[i-1][j-1] + cost   // substitution
                    );
                }
            }
            
            // Calculate similarity percentage
            const maxLength = Math.max(str1.length, str2.length);
            const distance = matrix[str1.length][str2.length];
            return Math.round((1 - distance / maxLength) * 100);
        }

        // Enhanced supplier matching
        function matchSupplier(hqSupplier, siteSupplier) {
            if (!hqSupplier || !siteSupplier) return { match: false, score: 0 };
            
            // Normalize supplier names
            const hqNormalized = normalizeText(hqSupplier);
            const siteNormalized = normalizeText(siteSupplier);
            
            // Exact match check
            if (hqNormalized === siteNormalized) {
                return { match: true, score: 10, exact: true };
            }
            
            // Check if site supplier contains HQ supplier or vice versa
            if (hqNormalized.includes(siteNormalized) || siteNormalized.includes(hqNormalized)) {
                return { match: true, score: 8, included: true };
            }
            
            // Check known suppliers and aliases
            for (const supplier of KNOWN_SUPPLIERS) {
                const supplierNormalized = normalizeText(supplier.name);
                const aliases = supplier.aliases.map(a => normalizeText(a));
                
                // Check if both match the same supplier or its aliases
                const hqMatches = hqNormalized === supplierNormalized || aliases.some(a => hqNormalized === a);
                const siteMatches = siteNormalized === supplierNormalized || aliases.some(a => siteNormalized === a);
                
                if (hqMatches && siteMatches) {
                    return { match: true, score: 9, aliasMatch: true };
                }
            }
            
            // Calculate string similarity as a fallback
            const similarity = calculateStringSimilarity(hqNormalized, siteNormalized);
            if (similarity >= 70) {
                return { match: true, score: 7, similarity };
            }
            
            return { match: false, score: 0, similarity };
        }

        // =====================================
        // DATE HANDLING
        // =====================================

        // Normalize "Ends today" to today's date in MM/DD/YYYY format
        function getTodayMMDDYYYY() {
            const today = new Date();
            const mm = String(today.getMonth()+1).padStart(2, '0');
            const dd = String(today.getDate()).padStart(2, '0');
            const yyyy = today.getFullYear();
            return `${mm}/${dd}/${yyyy}`;
        }

        // Parse date from various formats
        function parseDate(dStr) {
            if (!dStr) return null;
            
            // ISO format: YYYY-MM-DD
            let m = dStr.match(/^(\d{4})-(\d{2})-(\d{2})$/);
            if (m) return new Date(`${m[1]}-${m[2]}-${m[3]}T00:00:00`);
            
            // ISO format with time: YYYY-MM-DD HH:MM:SS
            m = dStr.match(/^(\d{4})-(\d{2})-(\d{2})[T\s].*$/);
            if (m) return new Date(`${m[1]}-${m[2]}-${m[3]}T00:00:00`);
            
            // US format: MM/DD/YYYY
            m = dStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
            if (m) return new Date(`${m[3]}-${m[1].padStart(2,'0')}-${m[2].padStart(2,'0')}T00:00:00`);
            
            return null;
        }

        // Check if two dates are within a specified range of days
        function datesWithinRange(dateA, dateB, days) {
            const d1 = parseDate(dateA);
            const d2 = parseDate(dateB);
            
            if (!d1 || !d2) return { match: false, difference: null };
            
            const diffTime = Math.abs(d1 - d2);
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            
            return { 
                match: diffDays <= days,
                difference: diffDays,
                direction: d1 > d2 ? 'later' : 'earlier'
            };
        }

        // Extract dates from a line (start/end if available)
        function extractDates(line) {
            const obj = { startDate: '', endDate: '', endsToday: false };
            
            // Check for "Ends today" pattern
            if (/Ends\s+today/i.test(line)) {
                obj.endsToday = true;
                obj.endDate = getTodayMMDDYYYY();
            }
            
            // Check for "Ends MM/DD/YYYY" pattern
            let m = line.match(/Ends\s+(\d{1,2}\/\d{1,2}\/\d{4})/i);
            if (m) {
                obj.endDate = m[1];
            }
            
            // Check for date range patterns
            const fullRangeRegex = /(\d{1,2}\/\d{1,2}\/\d{4})-(\d{1,2}\/\d{1,2}\/\d{4})/;
            const partialRangeRegex = /(\d{1,2}\/\d{1,2})-(\d{1,2}\/\d{1,2}\/\d{4})/;
            
            m = line.match(fullRangeRegex);
            if (m) {
                obj.startDate = m[1];
                obj.endDate = m[2];
                return obj;
            }
            
            m = line.match(partialRangeRegex);
            if (m) {
                const startMonth = m[1].split('/')[0];
                const startDay = m[1].split('/')[1];
                const endMonth = m[2].split('/')[0];
                const endDay = m[2].split('/')[1];
                const endYear = m[2].split('/')[2];
                
                // Infer year for start date from end date
                let startYear = endYear;
                // If start month is later than end month, it's likely from previous year
                if (parseInt(startMonth) > parseInt(endMonth)) {
                    startYear = (parseInt(endYear) - 1).toString();
                }
                
                obj.startDate = `${startMonth}/${startDay}/${startYear}`;
                obj.endDate = m[2];
            }
            
            return obj;
        }

        // =====================================
        // MONETARY VALUE EXTRACTION AND MATCHING
        // =====================================

        // Enhanced monetary token extraction with context
        function extractMonetaryValues(text) {
            if (!text) return [];
            
            const normalizedText = normalizeText(text);
            const monetaryValues = [];
            
            // Various patterns to catch monetary values in different formats
            const patterns = [
                // Dollar amounts: $100, 100 USD, 100 dollars
                /(?:^|[^\w])(\$?\s?\d+(?:\.\d+)?(?:\s*(?:usd|dollars|dollar))?)/gi,
                // Percentages: 10%, 10 percent, 10 percent off
                /(\d+(?:\.\d+)?(?:\s*%|\s*percent(?:\s*off)?|\s*discount))/gi,
                // Savings phrases: save $50, up to $100
                /(?:save|up to|get|receive|earn)(?:\s*an?\s*)?(?:\s*extra\s*)?(?:\s*complimentary\s*)?(\$?\s?\d+(?:\.\d+)?)/gi,
            ];
            
            patterns.forEach(pattern => {
                let match;
                while ((match = pattern.exec(normalizedText)) !== null) {
                    const value = match[1].trim();
                    monetaryValues.push(value);
                }
            });
            
            return [...new Set(monetaryValues)]; // Remove duplicates
        }

        // Normalize monetary value for comparison
        function normalizeMonetaryValue(value) {
            if (!value) return null;
            
            // Create simplified version for matching
            let normalized = value.toLowerCase()
                .replace(/[^\w\d%\$\.]/g, '')  // Remove all except digits, letters, %, $, and decimal
                .replace(/^save|upto|uptoan|getuptoa|receivea|earna/g, ''); // Remove common prefixes
            
            // Extract numeric part
            const numericMatch = normalized.match(/\d+(?:\.\d+)?/);
            if (!numericMatch) return null;
            
            const numericValue = parseFloat(numericMatch[0]);
            
            // Determine if it's a percentage or currency
            const isPercent = normalized.includes('%') || normalized.includes('percent') || normalized.includes('off');
            const isCurrency = normalized.includes('$') || CURRENCY_SYMBOLS.some(sym => normalized.includes(sym));
            
            return {
                original: value,
                normalized,
                numeric: numericValue,
                isPercent,
                isCurrency,
                type: isPercent ? 'percent' : (isCurrency ? 'currency' : 'other')
            };
        }

        // Compare monetary values based on the selected matching mode
        function compareMonetaryValues(hqValues, siteValues, matchType) {
            if (!hqValues.length || !siteValues.length) {
                return { match: false, score: 0, reason: 'No monetary values to compare' };
            }
            
            // Normalize all values
            const normalizedHQ = hqValues.map(normalizeMonetaryValue).filter(Boolean);
            const normalizedSite = siteValues.map(normalizeMonetaryValue).filter(Boolean);
            
            if (!normalizedHQ.length || !normalizedSite.length) {
                return { match: false, score: 0, reason: 'No valid monetary values after normalization' };
            }
            
            const matches = [];
            const mismatches = [];
            
            // Match based on the selected type
            if (matchType === 'exact') {
                // Exact matching requires exact numbers and same type
                normalizedHQ.forEach(hqValue => {
                    const match = normalizedSite.find(siteValue => 
                        hqValue.numeric === siteValue.numeric && hqValue.type === siteValue.type
                    );
                    
                    if (match) {
                        matches.push({ hq: hqValue, site: match });
                    } else {
                        mismatches.push({ hq: hqValue, site: null });
                    }
                });
            }
            else if (matchType === 'flexible') {
                // Flexible matching allows same numeric value regardless of format
                normalizedHQ.forEach(hqValue => {
                    const match = normalizedSite.find(siteValue => hqValue.numeric === siteValue.numeric);
                    
                    if (match) {
                        matches.push({ hq: hqValue, site: match });
                    } else {
                        // Look for approximate matches (±10% for currency values, exact for percentages)
                        if (hqValue.type === 'currency') {
                            const approxMatch = normalizedSite.find(siteValue => 
                                siteValue.type === 'currency' && 
                                Math.abs(hqValue.numeric - siteValue.numeric) / hqValue.numeric <= 0.1
                            );
                            
                            if (approxMatch) {
                                matches.push({ 
                                    hq: hqValue, 
                                    site: approxMatch, 
                                    approximate: true,
                                    difference: Math.abs(hqValue.numeric - approxMatch.numeric)
                                });
                            } else {
                                mismatches.push({ hq: hqValue, site: null });
                            }
                        } else {
                            mismatches.push({ hq: hqValue, site: null });
                        }
                    }
                });
            }
            else if (matchType === 'partial') {
                // Partial matching requires at least one match
                normalizedHQ.forEach(hqValue => {
                    // Try exact match first
                    let match = normalizedSite.find(siteValue => 
                        hqValue.numeric === siteValue.numeric && hqValue.type === siteValue.type
                    );
                    
                    // If no exact match, try flexible match
                    if (!match) {
                        match = normalizedSite.find(siteValue => hqValue.numeric === siteValue.numeric);
                    }
                    
                    // If still no match and it's currency, try approximate match
                    if (!match && hqValue.type === 'currency') {
                        match = normalizedSite.find(siteValue => 
                            siteValue.type === 'currency' && 
                            Math.abs(hqValue.numeric - siteValue.numeric) / hqValue.numeric <= 0.1
                        );
                        
                        if (match) {
                            matches.push({ 
                                hq: hqValue, 
                                site: match, 
                                approximate: true,
                                difference: Math.abs(hqValue.numeric - match.numeric)
                            });
                            return;
                        }
                    }
                    
                    if (match) {
                        matches.push({ hq: hqValue, site: match });
                    } else {
                        mismatches.push({ hq: hqValue, site: null });
                    }
                });
            }
            
            // Calculate score and determine match result
            let score = matches.length * 5;
            
            // For partial matching, we consider it a match if there's at least one matching value
            if (matchType === 'partial' && matches.length > 0) {
                return { 
                    match: true, 
                    score, 
                    matches, 
                    mismatches,
                    matchRatio: matches.length / normalizedHQ.length
                };
            }
            
            // For exact and flexible, all HQ values must have a match
            const allMatched = mismatches.length === 0;
            
            // If we have some matches but not perfect, reduce the score
            if (matches.length > 0 && !allMatched) {
                score = Math.max(1, Math.floor(score / 2));
            }
            
            return {
                match: allMatched,
                score: allMatched ? score : (matches.length > 0 ? score : 0),
                matches,
                mismatches,
                matchRatio: normalizedHQ.length ? matches.length / normalizedHQ.length : 0
            };
        }

        // =====================================
        // DATA PARSING AND DEAL CLASSIFICATION
        // =====================================

        // Parse HQ deals from raw text
        function parseHqDeals(rawText) {
            if (!rawText) return [];
            
            const lines = rawText.split('\n').map(l => l.trim()).filter(Boolean);
            const results = [];
            let currentSupplier = '';
            
            for (let line of lines) {
                // Skip category headers (lines starting with 'c')
                if (line.startsWith('c ')) {
                    continue;
                }
                
                // Identify supplier lines (those starting with "v" or ending with ":")
                if (line.startsWith('v') || line.endsWith(':') || 
                    KNOWN_SUPPLIERS.some(s => s.name.toLowerCase() === line.toLowerCase() || 
                                    s.aliases.some(a => a.toLowerCase() === line.toLowerCase()))) {
                    // Remove any preceding markers and colons
                    currentSupplier = line.replace(/^[cvd]\s*/i, '').replace(/:/g, '').trim();
                    continue;
                }
                
                // Process deal lines (starting with 'd')
                if (line.startsWith('d') || line.startsWith('ed')) {
                    const isExclusive = line.startsWith('ed');
                    line = line.replace(/^[eda]\s*/i, '').trim();
                    
                    // Create the deal object
                    const deal = {
                        supplier: currentSupplier,
                        dealText: line,
                        exclusive: isExclusive || /\bEXCLUSIVE\b/i.test(line),
                        startDate: '',
                        endDate: '',
                        score: 0,
                        possibleCandidate: null,
                        tokens: tokenizeDealText(line),
                        monetaryValues: extractMonetaryValues(line)
                    };
                    
                    // Extract dates from the deal text
                    const dateObj = extractDates(line);
                    deal.startDate = dateObj.startDate;
                    deal.endDate = dateObj.endDate;
                    
                    results.push(deal);
                }
            }
            
            return results;
        }

        // Parse site deals from JSON
        function parseSiteDeals(jsonArr) {
            if (!jsonArr || !jsonArr.length) return [];
            
            return jsonArr.map(item => {
                // Extract and normalize supplier name
                let supplier = (item.shopOverline || item.field_shopOverline_cmsuxrfz || '').trim();
                
                // Normalize known supplier names
                for (const knownSupplier of KNOWN_SUPPLIERS) {
                    if (supplier.toLowerCase().includes(knownSupplier.name.toLowerCase()) || 
                        knownSupplier.aliases.some(alias => supplier.toLowerCase().includes(alias.toLowerCase()))) {
                        supplier = knownSupplier.name;
                        break;
                    }
                }
                
                // Combine title and description for full text matching
                const title = (item.title || '').trim();
                const description = (item.shopListing || item.field_shopListing_gxrjxnpo || '').trim();
                const fullText = `${title} ${description}`.trim();
                
                // Extract dates
                let startDate = '';
                let endDate = '';
                
                if (item.postDate) {
                    startDate = item.postDate.includes('T') 
                        ? item.postDate.split('T')[0] 
                        : item.postDate.split(' ')[0];
                }
                
                if (item.expiryDate) {
                    endDate = item.expiryDate.includes('T') 
                        ? item.expiryDate.split('T')[0] 
                        : item.expiryDate.split(' ')[0];
                }
                
                // Determine if the deal is exclusive
                let isExclusive = false;
                if (item.dealCategory && Array.isArray(item.dealCategory)) {
                    isExclusive = item.dealCategory.includes(39542);
                } else {
                    isExclusive = /exclusive/i.test(fullText);
                }
                
                // Determine if the deal is active
                const isActive = (item.status && item.status.toLowerCase() === "live") || 
                                (item.enabled === 1 && item.enabledForSite === 1);
                
                return {
                    id: item.id,
                    supplier,
                    dealText: fullText,
                    title,
                    description,
                    startDate,
                    endDate,
                    isActive,
                    exclusive: isExclusive,
                    used: false,
                    tokens: tokenizeDealText(fullText),
                    monetaryValues: extractMonetaryValues(fullText)
                };
            });
        }

        // =====================================
        // SCORING AND MATCHING ALGORITHM
        // =====================================

        // Calculate match score between HQ deal and site deal with detailed breakdown
        function calculateMatchScore(hqDeal, siteDeal, options) {
            const scoreBreakdown = {
                supplierMatch: { score: 0, details: null },
                dateMatch: { score: 0, details: null },
                monetaryMatch: { score: 0, details: null },
                textSimilarity: { score: 0, details: null },
                tokenMatch: { score: 0, details: [] },
                total: 0
            };
            
            // 1. Supplier matching - required for any match
            const supplierResult = matchSupplier(hqDeal.supplier, siteDeal.supplier);
            scoreBreakdown.supplierMatch.details = supplierResult;
            
            if (!supplierResult.match) {
                return scoreBreakdown; // Bail early if suppliers don't match
            }
            
            scoreBreakdown.supplierMatch.score = supplierResult.score;
            
            // 2. Date matching - optional based on settings
            if (options.requireExpiry && hqDeal.endDate && siteDeal.endDate) {
                const dateResult = datesWithinRange(hqDeal.endDate, siteDeal.endDate, options.dateRangeThreshold);
                scoreBreakdown.dateMatch.details = dateResult;
                
                if (!dateResult.match && options.requireExpiry) {
                    // If expiry matching is required and dates don't match, bail early
                    return scoreBreakdown;
                }
                
                if (dateResult.match) {
                    // Score is higher for closer dates
                    const daysBonus = options.dateRangeThreshold - (dateResult.difference || 0);
                    scoreBreakdown.dateMatch.score = 10 + daysBonus;
                }
            }
            
            // 3. Monetary value matching - optional based on settings
            const monetaryResult = compareMonetaryValues(
                hqDeal.monetaryValues, 
                siteDeal.monetaryValues, 
                options.monetaryMatchType
            );
            
            scoreBreakdown.monetaryMatch.details = monetaryResult;
            
            if (options.requireMonetary && !monetaryResult.match) {
                // If monetary matching is required and values don't match, bail early
                return scoreBreakdown;
            }
            
            if (monetaryResult.match) {
                scoreBreakdown.monetaryMatch.score = monetaryResult.score;
            }
            
            // 4. Text similarity matching
            if (options.enableFuzzyMatching) {
                const similarityScore = calculateStringSimilarity(hqDeal.dealText, siteDeal.dealText);
                scoreBreakdown.textSimilarity.details = { similarity: similarityScore };
                
                // Add score if similarity is above threshold
                if (similarityScore >= options.fuzzyMatchThreshold) {
                    scoreBreakdown.textSimilarity.score = Math.floor(similarityScore / 10);
                }
            }
            
            // 5. Token matching for additional scoring
            const hqTokens = hqDeal.tokens;
            const siteTokens = siteDeal.tokens;
            let tokenScore = 0;
            
            hqTokens.forEach(token => {
                if (siteTokens.includes(token)) {
                    let points = 1;
                    if (DEAL_KEYWORDS.has(token)) {
                        points = 3; // Bonus for key terms
                    }
                    
                    tokenScore += points;
                    scoreBreakdown.tokenMatch.details.push({
                        token,
                        points,
                        isKeyword: DEAL_KEYWORDS.has(token)
                    });
                }
            });
            
            scoreBreakdown.tokenMatch.score = tokenScore;
            
            // Calculate total score
            scoreBreakdown.total = (
                scoreBreakdown.supplierMatch.score +
                scoreBreakdown.dateMatch.score +
                scoreBreakdown.monetaryMatch.score +
                scoreBreakdown.textSimilarity.score +
                scoreBreakdown.tokenMatch.score
            );
            
            return scoreBreakdown;
        }

        // Find best site match for an HQ deal
        function findBestSiteMatch(hqDeal, siteDeals, options) {
            let bestMatch = {
                index: -1,
                score: 0,
                breakdown: null
            };
            
            const candidateMatches = [];
            
            for (let i = 0; i < siteDeals.length; i++) {
                const siteDeal = siteDeals[i];
                
                // Skip already used deals
                if (siteDeal.used) continue;
                
                // Don't skip expired deals anymore - they may be valid matches
                // Calculate score with detailed breakdown
                const scoreBreakdown = calculateMatchScore(hqDeal, siteDeal, options);
                const score = scoreBreakdown.total;
                
                // Save all potential matches for debugging
                if (score > 0) {
                    candidateMatches.push({
                        index: i,
                        score,
                        breakdown: scoreBreakdown,
                        deal: siteDeal,
                        isExpired: isExpired(siteDeal)
                    });
                }
                
                // Update best match if this is better and not expired, or if we have no matches yet
                if ((score > bestMatch.score && !isExpired(siteDeal)) || (bestMatch.index === -1 && score > 0)) {
                    bestMatch = {
                        index: i,
                        score,
                        breakdown: scoreBreakdown
                    };
                }
            }
            
            // Add all candidate matches to the best match object for debugging
            bestMatch.candidates = candidateMatches.sort((a, b) => b.score - a.score);
            
            return bestMatch;
        }

        // Helper function to check if a site deal is expired
        function isExpired(siteDeal) {
            const now = new Date();
            const exp = parseDate(siteDeal.endDate);
            return exp && exp < now;
        }

        // =====================================
        // UI FUNCTIONS
        // =====================================

        // Add a row to the duplicates table
        function addDuplicateRow(hqDeal, siteDeal, breakdown, tableBody) {
            const dealStatus = getSiteDealStatus(siteDeal);
            
            const tr = document.createElement('tr');
            tr.setAttribute('data-supplier', hqDeal.supplier);
            tr.setAttribute('data-start', hqDeal.startDate);
            tr.setAttribute('data-end', hqDeal.endDate);
            tr.setAttribute('data-score', breakdown.total);
            tr.setAttribute('data-status', dealStatus);
            tr.setAttribute('data-exclusive', hqDeal.exclusive ? 'Yes' : 'No');
            
            // Create the match details
            const matchDetails = [];
            
            if (breakdown.supplierMatch.score > 0) {
                matchDetails.push(`<span class="match-detail match-detail-success">Supplier +${breakdown.supplierMatch.score}</span>`);
            }
            
            if (breakdown.dateMatch.score > 0) {
                matchDetails.push(`<span class="match-detail match-detail-success">Date +${breakdown.dateMatch.score}</span>`);
            }
            
            if (breakdown.monetaryMatch.score > 0) {
                matchDetails.push(`<span class="match-detail match-detail-success">Money +${breakdown.monetaryMatch.score}</span>`);
            }
            
            if (breakdown.textSimilarity.score > 0) {
                matchDetails.push(`<span class="match-detail match-detail-info">Text +${breakdown.textSimilarity.score}</span>`);
            }
            
            if (breakdown.tokenMatch.score > 0) {
                matchDetails.push(`<span class="match-detail match-detail-info">Tokens +${breakdown.tokenMatch.score}</span>`);
            }
            
            tr.innerHTML = `
                <td><strong>${hqDeal.supplier}</strong><br/>${hqDeal.dealText}</td>
                <td><small>${hqDeal.startDate || '-'}</small></td>
                <td><small>${hqDeal.endDate || '-'}</small></td>
                <td>${breakdown.total}</td>
                <td>${matchDetails.join(' ')}</td>
                <td>
                    <strong>${siteDeal.supplier}</strong><br/>
                    ${siteDeal.dealText}<br/>
                    <small>Expiry: ${siteDeal.endDate || 'n/a'}</small>
                </td>
                <td>${dealStatus}</td>
                <td>${hqDeal.exclusive ? 'Yes' : 'No'}</td>
                <td><i class="icon-btn fas fa-thumbs-down" title="Move to New Deals"></i></td>
            `;
            
            const downBtn = tr.querySelector('.fa-thumbs-down');
            downBtn.addEventListener('click', () => {
                tr.parentNode.removeChild(tr);
                siteDeal.used = false;
                addNewDealRow(hqDeal, document.getElementById('newDealsTable').querySelector('tbody'));
                updateMatchSummary();
            });
            
            tableBody.appendChild(tr);
        }

        // Add a row to the new deals table
        function addNewDealRow(hqDeal, tableBody) {
            const tr = document.createElement('tr');
            tr.setAttribute('data-supplier', hqDeal.supplier);
            tr.setAttribute('data-start', hqDeal.startDate);
            tr.setAttribute('data-end', hqDeal.endDate);
            tr.setAttribute('data-score', hqDeal.candidateScore || 0);
            tr.setAttribute('data-exclusive', hqDeal.exclusive ? 'Yes' : 'No');
            
            let candidateHtml = '<small>No candidate match found</small>';
            let buttonClass = 'btn-light';
            let buttonDisabled = true;
            
            if (hqDeal.possibleCandidate) {
                const candidateMatch = hqDeal.possibleCandidate;
                const isExpiredMatch = isExpired(candidateMatch);
                
                candidateHtml = `
                    <small class="best-candidate-preview">
                        <strong>${candidateMatch.supplier}</strong> - 
                        ${candidateMatch.dealText.slice(0, 100) + (candidateMatch.dealText.length > 100 ? '...' : '')}
                        ${isExpiredMatch ? '<br><span class="text-danger">This match is expired</span>' : ''}
                    </small>
                `;
                
                // Allowing interaction with expired matches, just with visual warning
                buttonClass = isExpiredMatch ? 'btn-warning' : 'btn-outline-primary';
                buttonDisabled = false;
            }
            
            tr.innerHTML = `
                <td><strong>${hqDeal.supplier}</strong><br/>${hqDeal.dealText}</td>
                <td><small>${hqDeal.startDate || '-'}</small></td>
                <td><small>${hqDeal.endDate || '-'}</small></td>
                <td><span class="clickable score-cell">${hqDeal.candidateScore || 0}</span></td>
                <td>${hqDeal.exclusive ? 'Yes' : 'No'}</td>
                <td class="candidate-cell">${candidateHtml}</td>
                <td><button class="btn btn-sm ${buttonClass} match-btn" ${buttonDisabled ? 'disabled' : ''}>Match</button></td>
            `;
            
            const scoreCell = tr.querySelector('.score-cell');
            const candidateCell = tr.querySelector('.candidate-cell');
            const matchBtn = tr.querySelector('.match-btn');
            
            // Add event listeners only if there's a candidate
            if (hqDeal.possibleCandidate) {
                scoreCell.addEventListener('click', () => showCandidateModal(hqDeal, tr));
                candidateCell.addEventListener('click', () => showCandidateModal(hqDeal, tr));
                matchBtn.addEventListener('click', () => showCandidateModal(hqDeal, tr));
            }
            
            tableBody.appendChild(tr);
        }

        // Compute site deal status (Active or Expired)
        function getSiteDealStatus(siteDeal) {
            const now = new Date();
            const exp = parseDate(siteDeal.endDate);
            return (exp && exp < now) ? "Expired" : "Active";
        }

        // Update match summary statistics
        function updateMatchSummary() {
            const duplicatesTable = document.getElementById('duplicatesTable');
            const newDealsTable = document.getElementById('newDealsTable');
            
            const duplicatesCount = duplicatesTable.querySelectorAll('tbody tr').length;
            const newDealsCount = newDealsTable.querySelectorAll('tbody tr').length;
            const totalDeals = duplicatesCount + newDealsCount;
            
            const matchPercent = totalDeals > 0 
                ? Math.round((duplicatesCount / totalDeals) * 100) 
                : 0;
            
            document.getElementById('matchSummary').innerHTML = `
                <div class="d-flex justify-content-between">
                    <div>
                        <strong>Total Deals:</strong> ${totalDeals}<br>
                        <strong>Matched Deals:</strong> ${duplicatesCount} (${matchPercent}%)<br>
                        <strong>Unmatched Deals:</strong> ${newDealsCount} (${100 - matchPercent}%)
                    </div>
                    <div>
                        <div class="progress" style="height: 30px; width: 200px; margin-top: 10px;">
                            <div class="progress-bar bg-success" role="progressbar" 
                                style="width: ${matchPercent}%;" 
                                aria-valuenow="${matchPercent}" aria-valuemin="0" aria-valuemax="100">
                                ${matchPercent}% Matched
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Show detailed candidate match information in a modal
        function showCandidateModal(hqDeal, newRowElement) {
            currentNewRow = {
                deal: hqDeal,
                rowEl: newRowElement
            };
            
            const candidate = hqDeal.possibleCandidate;
            const candidateStatus = candidate ? getSiteDealStatus(candidate) : "N/A";
            const scoreBreakdown = hqDeal.candidateBreakdown || {};
            const isExpiredMatch = candidate ? isExpired(candidate) : false;
            
            // Basic candidate information
            let detailsHtml = `
                <div class="row">
                    <div class="col-md-6">
                        <h5>HQ Deal</h5>
                        <p><strong>Supplier:</strong> ${hqDeal.supplier}</p>
                        <p><strong>Deal Text:</strong> ${hqDeal.dealText}</p>
                        <p><strong>Expiry:</strong> ${hqDeal.endDate || 'n/a'}</p>
                        <p><strong>Monetary Values:</strong> ${hqDeal.monetaryValues?.join(', ') || 'None'}</p>
                    </div>
                    <div class="col-md-6">
                        <h5>Candidate Site Deal ${isExpiredMatch ? '<span class="badge bg-warning">Expired</span>' : ''}</h5>
                        <p><strong>Supplier:</strong> ${candidate.supplier}</p>
                        <p><strong>Deal Text:</strong> ${candidate.dealText}</p>
                        <p><strong>Expiry:</strong> ${candidate.endDate || 'n/a'} (${candidateStatus})</p>
                        <p><strong>Monetary Values:</strong> ${candidate.monetaryValues?.join(', ') || 'None'}</p>
                    </div>
                </div>
                ${isExpiredMatch ? '<div class="alert alert-warning">This deal is expired but matches the HQ deal. You can still create a match if appropriate.</div>' : ''}
            `;
            
            document.getElementById('candidateDetails').innerHTML = detailsHtml;
            
            // Detailed matching analysis
            let analysisHtml = `
                <h5>Matching Analysis <span class="badge bg-primary">Total Score: ${hqDeal.candidateScore || 0}</span></h5>
                <div class="row">
                    <div class="col-md-6">
                        <h6>Supplier Match <span class="badge bg-success score-breakdown">+${scoreBreakdown.supplierMatch?.score || 0}</span></h6>
                        <div class="small-text">
                            ${scoreBreakdown.supplierMatch?.details?.exact ? 'Exact match found' : 
                            scoreBreakdown.supplierMatch?.details?.included ? 'Partial match found' :
                            scoreBreakdown.supplierMatch?.details?.aliasMatch ? 'Matched via known alias' :
                            'Matched via text similarity'}
                        </div>
                        
                        <h6>Date Match <span class="badge bg-${scoreBreakdown.dateMatch?.score > 0 ? 'success' : 'danger'} score-breakdown">+${scoreBreakdown.dateMatch?.score || 0}</span></h6>
                        <div class="small-text">
                            ${scoreBreakdown.dateMatch?.details?.match ? 
                            `Dates within threshold: ${scoreBreakdown.dateMatch.details.difference} days ${scoreBreakdown.dateMatch.details.direction}` : 
                            'Dates do not match within threshold'}
                        </div>
                        
                        <h6>Text Similarity <span class="badge bg-info score-breakdown">+${scoreBreakdown.textSimilarity?.score || 0}</span></h6>
                        <div class="small-text">
                            Overall text similarity: ${scoreBreakdown.textSimilarity?.details?.similarity || 0}%
                        </div>
                    </div>
                    <div class="col-md-6">
                        <h6>Monetary Match <span class="badge bg-${scoreBreakdown.monetaryMatch?.score > 0 ? 'success' : 'warning'} score-breakdown">+${scoreBreakdown.monetaryMatch?.score || 0}</span></h6>
                        <div class="small-text">
                            ${scoreBreakdown.monetaryMatch?.details?.matches?.length ? 
                            `${scoreBreakdown.monetaryMatch.details.matches.length} value(s) matched` : 
                            'No monetary values matched'}
                            ${scoreBreakdown.monetaryMatch?.details?.matchRatio ? 
                            ` (match ratio: ${Math.round(scoreBreakdown.monetaryMatch.details.matchRatio * 100)}%)` : ''}
                        </div>
                        
                        <h6>Token Match <span class="badge bg-info score-breakdown">+${scoreBreakdown.tokenMatch?.score || 0}</span></h6>
                        <div class="small-text">
                            ${scoreBreakdown.tokenMatch?.details?.length ? 
                            `${scoreBreakdown.tokenMatch.details.length} token(s) matched` : 
                            'No tokens matched'}
                            ${scoreBreakdown.tokenMatch?.details?.filter(t => t.isKeyword).length ? 
                            ` (${scoreBreakdown.tokenMatch.details.filter(t => t.isKeyword).length} keywords)` : ''}
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('matchingAnalysis').innerHTML = analysisHtml;
            
            const modal = new bootstrap.Modal(document.getElementById('matchModal'));
            modal.show();
        }

        // Copy new deals to clipboard in a formatted way
        function copyNewDealsToClipboard() {
            const newTableBody = document.getElementById('newDealsTable').querySelector('tbody');
            const rows = Array.from(newTableBody.querySelectorAll('tr'));
            let lastSupplier = "";
            let lines = [];
            
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (!cells.length) return;
                
                const supplierLine = cells[0].innerText.split('\n');
                const supplier = supplierLine[0].trim();
                const dealText = supplierLine.slice(1).join(' ').trim();
                const isExclusive = (cells[4].innerText.trim() === "Yes");
                
                if (supplier !== lastSupplier) {
                    lines.push(`v\t${supplier}:`);
                    lastSupplier = supplier;
                }
                
                if (isExclusive) {
                    lines.push(`ed\t${dealText}`);
                } else {
                    lines.push(`d\t${dealText}`);
                }
            });
            
            const finalText = lines.join('\n');
            navigator.clipboard.writeText(finalText)
                .then(() => alert("Copied new deals in c/v/d/ed format!"))
                .catch(err => console.error("Copy failed:", err));
        }

        // Enable sorting for table columns
        function enableTableSorting(tableId) {
            const table = document.getElementById(tableId);
            const headers = table.querySelectorAll('th.sortable');
            
            headers.forEach(header => {
                let ascending = true;
                header.addEventListener('click', () => {
                    const sortKey = header.getAttribute('data-sort');
                    let sortType = "string";
                    
                    if (sortKey === "score") sortType = "number";
                    if (sortKey === "start" || sortKey === "end") sortType = "date";
                    if (sortKey === "supplier" || sortKey === "exclusive" || sortKey === "status") sortType = "string";
                    
                    const tbody = table.querySelector('tbody');
                    sortTableRows(tbody, sortKey, sortType, ascending);
                    ascending = !ascending;
                });
            });
        }

        // Sort table rows based on a given key and type
        function sortTableRows(tableBody, sortKey, sortType, ascending = true) {
            const rows = Array.from(tableBody.querySelectorAll('tr'));
            
            rows.sort((a, b) => {
                let aVal = a.getAttribute(`data-${sortKey}`) || "";
                let bVal = b.getAttribute(`data-${sortKey}`) || "";
                
                if (sortType === "number") {
                    return ascending ? (Number(aVal) - Number(bVal)) : (Number(bVal) - Number(aVal));
                }
                
                if (sortType === "date") {
                    // Handle empty dates
                    if (!aVal && !bVal) return 0;
                    if (!aVal) return ascending ? -1 : 1;
                    if (!bVal) return ascending ? 1 : -1;
                    
                    return ascending ? (Date.parse(aVal) - Date.parse(bVal)) : (Date.parse(bVal) - Date.parse(aVal));
                }
                
                aVal = aVal.toLowerCase();
                bVal = bVal.toLowerCase();
                
                if (aVal < bVal) return ascending ? -1 : 1;
                if (aVal > bVal) return ascending ? 1 : -1;
                return 0;
            });
            
            rows.forEach(row => tableBody.appendChild(row));
        }

        // Add debug information
        function updateDebugInfo(hqDeals, siteDeals, options) {
            const uniqueSuppliers = new Set();
            hqDeals.forEach(deal => uniqueSuppliers.add(deal.supplier));
            
            const uniqueSiteSuppliers = new Set();
            siteDeals.forEach(deal => uniqueSiteSuppliers.add(deal.supplier));
            
            const monetaryHQ = hqDeals.filter(d => d.monetaryValues.length > 0).length;
            const monetarySite = siteDeals.filter(d => d.monetaryValues.length > 0).length;
            
            const dateHQ = hqDeals.filter(d => d.endDate).length;
            const dateSite = siteDeals.filter(d => d.endDate).length;
            
            document.getElementById('debugInfo').innerHTML = `
                <div class="row">
                    <div class="col-md-6">
                        <strong>HQ Deals:</strong> ${hqDeals.length}<br>
                        <strong>Unique Suppliers:</strong> ${uniqueSuppliers.size}<br>
                        <strong>With Monetary Values:</strong> ${monetaryHQ} (${Math.round(monetaryHQ/hqDeals.length*100)}%)<br>
                        <strong>With End Dates:</strong> ${dateHQ} (${Math.round(dateHQ/hqDeals.length*100)}%)<br>
                    </div>
                    <div class="col-md-6">
                        <strong>Site Deals:</strong> ${siteDeals.length}<br>
                        <strong>Unique Suppliers:</strong> ${uniqueSiteSuppliers.size}<br>
                        <strong>With Monetary Values:</strong> ${monetarySite} (${Math.round(monetarySite/siteDeals.length*100)}%)<br>
                        <strong>With End Dates:</strong> ${dateSite} (${Math.round(dateSite/siteDeals.length*100)}%)<br>
                    </div>
                </div>
                <div class="mt-2">
                    <strong>Match Options:</strong><br>
                    Score Threshold: ${options.minScoreThreshold}, 
                    Fuzzy Threshold: ${options.fuzzyMatchThreshold}%, 
                    Date Range: ${options.dateRangeThreshold} days,
                    Monetary Match: ${options.monetaryMatchType}
                </div>
            `;
        }

        // =====================================
        // MAIN LOGIC AND EVENT HANDLERS
        // =====================================

        // Global variable to store current row for modal actions
        let currentNewRow = null;

        // Parse and classify deals
        document.getElementById('parseButton').addEventListener('click', () => {
            // Get user-defined thresholds
            const options = {
                minScoreThreshold: parseFloat(document.getElementById('minScoreThreshold').value) || 3,
                fuzzyMatchThreshold: parseInt(document.getElementById('fuzzyMatchThreshold').value) || 50,
                dateRangeThreshold: parseInt(document.getElementById('dateRangeThreshold').value) || 3,
                monetaryMatchType: document.getElementById('monetaryMatchType').value,
                requireExpiry: document.getElementById('requireExpiry').checked,
                requireMonetary: document.getElementById('requireMonetary').checked,
                enableFuzzyMatching: document.getElementById('enableFuzzyMatching').checked
            };
            
            // Parse input data
            const rawHq = document.getElementById('hqDealsInput').value;
            const hqDeals = parseHqDeals(rawHq);
            
            let siteJson = [];
            try {
                siteJson = JSON.parse(document.getElementById('siteDealsInput').value);
            } catch (e) {
                alert("Error parsing site JSON. Check your formatting!");
                return;
            }
            
            const siteDeals = parseSiteDeals(siteJson);
            
            // Reset tables
            const duplicatesBody = document.getElementById('duplicatesTable').querySelector('tbody');
            const newDealsBody = document.getElementById('newDealsTable').querySelector('tbody');
            duplicatesBody.innerHTML = '';
            newDealsBody.innerHTML = '';
            
            // Show results section
            document.getElementById('resultsSection').classList.remove('d-none');
            
            // Process each HQ deal
            for (const deal of hqDeals) {
                const matchResult = findBestSiteMatch(deal, siteDeals, options);
                deal.candidateScore = matchResult.score;
                deal.candidateBreakdown = matchResult.breakdown;
                
                if (matchResult.index !== -1 && matchResult.score >= options.minScoreThreshold) {
                    let matchedSite = siteDeals[matchResult.index];
                    matchedSite.used = true;
                    addDuplicateRow(deal, matchedSite, matchResult.breakdown, duplicatesBody);
                } else {
                    if (matchResult.index !== -1 && matchResult.score > 0) {
                        deal.possibleCandidate = siteDeals[matchResult.index];
                    }
                    addNewDealRow(deal, newDealsBody);
                }
            }
            
            // Update summary and debug info
            updateMatchSummary();
            updateDebugInfo(hqDeals, siteDeals, options);
        });

        // Handle the modal match button
        document.getElementById('modalMatchBtn').addEventListener('click', () => {
            if (!currentNewRow) return;
            
            const hqDeal = currentNewRow.deal;
            const newRow = currentNewRow.rowEl;
            
            if (hqDeal.possibleCandidate) {
                // Remove from new deals table
                newRow.parentNode.removeChild(newRow);
                
                // Mark site deal as used
                hqDeal.possibleCandidate.used = true;
                
                // Add to duplicates table
                addDuplicateRow(
                    hqDeal, 
                    hqDeal.possibleCandidate, 
                    hqDeal.candidateBreakdown, 
                    document.getElementById('duplicatesTable').querySelector('tbody')
                );
                
                // Update summary
                updateMatchSummary();
            }
            
            // Reset current row and close modal
            currentNewRow = null;
            const modalEl = document.getElementById('matchModal');
            const modal = bootstrap.Modal.getInstance(modalEl);
            modal.hide();
        });

        // Copy new deals to clipboard
        document.getElementById('copyButton').addEventListener('click', copyNewDealsToClipboard);

        // Initialize table sorting
        document.addEventListener('DOMContentLoaded', () => {
            enableTableSorting("duplicatesTable");
            enableTableSorting("newDealsTable");
        });
    </script>
</body>
</html>
