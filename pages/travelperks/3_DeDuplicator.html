<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Deal Matcher</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 20px;
      color: #333;
      line-height: 1.6;
      background-color: #f9f9f9;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    h1, h2 {
      color: #2c3e50;
    }

    h1 {
      border-bottom: 2px solid #eee;
      padding-bottom: 10px;
    }

    textarea {
      width: 100%;
      height: 150px;
      margin-bottom: 20px;
      font-family: 'Courier New', monospace;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 12px;
      transition: border 0.3s;
    }

    textarea:focus {
      border-color: #3498db;
      outline: none;
      box-shadow: 0 0 5px rgba(52, 152, 219, 0.5);
    }

    button {
      padding: 8px 15px;
      cursor: pointer;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      font-weight: 600;
      transition: background 0.3s;
      margin: 5px;
    }

    button:hover {
      background-color: #2980b9;
    }

    .action-button {
      margin-right: 10px;
    }

    .control-bar {
      margin: 15px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .threshold-control {
      display: flex;
      align-items: center;
    }

    .threshold-control label {
      margin-right: 10px;
      font-weight: 600;
    }

    .threshold-control input {
      width: 60px;
      padding: 5px;
      border-radius: 4px;
      border: 1px solid #ddd;
    }

    .matched-deal,
    .non-matched-deal {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 12px;
      margin-bottom: 15px;
      border-radius: 4px;
      background-color: #f8f9fa;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      transition: background-color 0.3s;
    }

    .matched-deal:hover,
    .non-matched-deal:hover {
      background-color: #e9f7fe;
    }

    .matched-deal {
      border-left: 4px solid #2ecc71;
    }

    .matched-deal.possible-date-change {
      border-left: 4px solid orange !important;
      background-color: #fff8e1;
    }

    .non-matched-deal {
      border-left: 4px solid #e74c3c;
      align-items: center;
    }

    .deal-info {
      flex: 1;
    }

    .deal-vendor {
      font-weight: bold;
      color: #3498db;
    }

    .match-score {
      background-color: #f39c12;
      color: white;
      font-weight: bold;
      border-radius: 50%;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 10px;
    }

    .json-match {
      flex: 1;
      background-color: #f1f8e9;
      padding: 12px;
      margin-left: 15px;
      font-size: 0.95em;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .expiry-date {
      background-color: #ffe0b2;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 600;
      display: inline-block;
    }

    .hq-date-mismatch {
      color: #985c04;
      background: #ffe0b2;
      border-radius: 0.35em;
      border-bottom: 1.5px dotted orange;
      padding: 0 4px;
    }

    .hq-date-mismatch small {
      color: #d8870f;
    }

    .price-value {
      background-color: #e8f5e9;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 600;
    }

    .percentage-value {
      background-color: #e3f2fd;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 600;
    }

    .keyword {
      background-color: #ede7f6;
      padding: 2px 6px;
      border-radius: 3px;
      margin: 0 2px;
      font-size: 0.9em;
    }

    .keyword-flag {
      background-color: #e1bee7;
      color: #6a1b9a;
      padding: 2px 5px;
      border-radius: 2px;
      font-size: 0.93em;
      margin: 1px 2px;
      font-weight: 600;
      display: inline-block;
      vertical-align: middle;
    }

    .tooltip {
      position: relative;
      display: inline-block;
      margin-left: 10px;
    }

    .tooltip .tooltiptext {
      visibility: hidden;
      width: 250px;
      background-color: #555;
      color: #fff;
      text-align: left;
      border-radius: 6px;
      padding: 10px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -125px;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 0.9em;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      line-height: 1.4;
    }

    .tooltip .tooltiptext::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      margin-left: -5px;
      border-width: 5px;
      border-style: solid;
      border-color: #555 transparent transparent transparent;
    }

    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }

    .section {
      margin-bottom: 30px;
      padding: 15px;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .section h2 {
      margin-top: 0;
      display: flex;
      align-items: center;
    }

    .section h2 .count-badge {
      background-color: #3498db;
      color: white;
      font-size: 0.7em;
      padding: 3px 8px;
      border-radius: 20px;
      margin-left: 10px;
    }

    .actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 10px;
    }

    .search-filter {
      margin-bottom: 15px;
    }

    .search-filter input {
      padding: 8px;
      width: 300px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .help-text {
      background-color: #f8f9fa;
      padding: 10px 15px;
      border-left: 3px solid #3498db;
      margin-bottom: 20px;
      border-radius: 4px;
    }

    .no-matches {
      padding: 20px;
      text-align: center;
      color: #7f8c8d;
      font-style: italic;
    }

    .date-flag {
      background-color: #ff980012;
      border-bottom: 2px dotted orange;
      color: #d35400;
      font-size: 0.96em;
      padding: 2px 6px 2px 4px;
      border-radius: 3px;
      margin-right: 6px;
      font-weight: 700;
      letter-spacing: 0.03em;
      display: inline-block;
      vertical-align:baseline;
    }

    .exclusive-flag {
      background: linear-gradient(90deg,#fceabb 30%,#f8b500 88%);
      color: #b24b00;
      padding: 2px 6px;
      border-radius: 3px;
      margin-right: 6px;
      font-weight: 700;
      font-size: 0.92em;
      letter-spacing: 0.05em;
      display: inline-block;
    }

    @media (max-width: 768px) {
      .matched-deal, .non-matched-deal {
        flex-direction: column;
      }
      
      .json-match {
        margin-left: 0;
        margin-top: 10px;
      }
      .date-flag,.exclusive-flag {margin-bottom:5px;}
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Deal Matcher</h1>
    <div class="help-text">
      Paste your HQ deals (vendor lines start with <code>v</code> and deal lines with <code>d</code> or <code>ed</code>)
      in the first box and the JSON export from your site in the second box. Then click "Compare Deals."
    </div>

    <div class="section">
      <h2>HQ Deals</h2>
      <textarea id="hqDeals" placeholder="Example:
v	Carnival:
d	Early Saver-Reduced Deposit & Up to $50 OBC (PEM/OB7): 03/31/2025
ed	More=Merrier Sale-Save up to $125 per room & $25 NRD (PHY): 03/24/2025-03/29/2025
d	72 Hour Sale-Great Guarantee Rates (P3P): 03/25/2025-03/27/2025
"></textarea>

      <h2>JSON Deals</h2>
      <textarea id="jsonDeals" placeholder='Example:
[
  {
    "shopOverline": "Carnival",
    "expiryDate": "2025-03-31T16:00:00-07:00",
    "title": "Early Saver-Reduced Deposit & Up to $50 OBC (PEM/OB7): 03/31/2025",
    "shopListing": "More=Merrier Sale-Save up to $125 per room & $25 NRD (PHY): 03/24/2025-03/29/2025"
  }
]'></textarea>

      <div class="control-bar">
        <div class="threshold-control">
          <label for="matchThreshold">Match Threshold:</label>
          <input type="number" id="matchThreshold" value="80" min="0" max="400" step="10">
          <div class="tooltip">‚ÑπÔ∏è
            <span class="tooltiptext">
              Adjust the minimum score required for a match. Higher values are more strict.
              <br>‚Ä¢ 0-70: Very loose matching
              <br>‚Ä¢ 80-100: Default threshold
              <br>‚Ä¢ 150+: Stricter matching
              <br>‚Ä¢ 200+: Very strict matching
            </span>
          </div>
        </div>
        <button id="compareButton">Compare Deals</button>
      </div>
    </div>

    <!-- Results Section -->
    <div class="section">
      <h2>Matched Deals <span class="count-badge" id="matchedCount">0</span></h2>
      <div class="search-filter">
        <input type="text" id="matchedFilter" placeholder="Filter matched deals...">
      </div>
      <div id="matchedDealsContainer"></div>
    </div>

    <div class="section">
      <h2>Non-Matched Deals <span class="count-badge" id="nonMatchedCount">0</span></h2>
      <div class="search-filter">
        <input type="text" id="nonMatchedFilter" placeholder="Filter non-matched deals...">
      </div>
      <div id="nonMatchedDealsContainer"></div>
      <div class="actions">
        <button id="copyButton">Copy Non-Matched Deals to Clipboard</button>
      </div>
    </div>
  </div>

  <script>
    // === Supplier Mapping Placeholders ===
    // The complete list of known suppliers (from your provided list)
    const knownSuppliers = [
      "Abercrombie & Kent",
      "Adventures by Disney",
      "African Travel",
      "Ama Waterways",
      "American Airline Vacations",
      "American Cruise Line",
      "Aulani, A Disney Resort & Spa",
      "Avalon Waterways",
      "Azamara",
      "Beaches",
      "BlueSky Tours",
      "Breathless",
      "Carnival",
      "Celebrity Cruises",
      "CIE Tours",
      "Club Med",
      "Collette",
      "CroisiEurope",
      "Crystal Cruises",
      "Cunard",
      "Delta Vacations",
      "Disney Cruise Line",
      "Disneyland",
      "DisneyWorld",
      "Dreams",
      "El Dorado Spa Resorts & Hotels",
      "Emerald Cruises",
      "Excellence Resorts",
      "Explora Journeys",
      "Four Seasons Yachts",
      "Funjet",
      "G Adventures",
      "Globus Journeys",
      "Great Safaris",
      "Hard Rock Hotels",
      "Holland America Line",
      "Hurtigruten",
      "Iberostar Hotels & Resorts",
      "Karisma Hotels & Resorts",
      "Lindblad Expeditions & National Geographic",
      "MSC Cruises",
      "Norwegian",
      "Oceania Cruises",
      "Outrigger Hotels & Resorts",
      "Palace Resorts",
      "Paul Gauguin Cruises",
      "Ponant",
      "Princess",
      "Project Expedition",
      "Regent Seven Seas Cruises",
      "Ritz-Carlton Yacht Collection",
      "RIU Hotels & Resorts",
      "Riverside Cruises",
      "Riviera River Cruises",
      "Rocky Mountaineer",
      "Royal Caribbean",
      "Sandals",
      "Scenic Eclipse Ocean Voyages",
      "Scenic River",
      "Seabourn",
      "Secrets",
      "Shore Excursions Group",
      "Silversea",
      "Southwest Vacations",
      "Star Clippers",
      "Tauck Cruises",
      "Tauck Tours",
      "TourSales.com",
      "Trafalgar",
      "UnCruise Adventures",
      "Uniworld",
      "United Vacations",
      "Viking Ocean",
      "Viking River",
      "Viator",
      "Virgin Voyages",
      "Villas of Distinction",
      "Windstar",
      "Zo√´try Wellness & Spa Resorts"
    ];
    const aliasMapping = {
      // American Airline Vacations
      "american airlines vacations": "American Airline Vacations",
      "american airline vacations": "American Airline Vacations",
      "american airlnes vacations": "American Airline Vacations",
      // Royal Caribbean
      "royal": "Royal Caribbean",
      "rccL": "Royal Caribbean",
      "rcc": "Royal Caribbean",
      "royal caribbean": "Royal Caribbean",
      // Norwegian
      "norwegian": "Norwegian",
      "norwegian cruise": "Norwegian",
      "norwegian cruise line": "Norwegian",
      "ncl": "Norwegian",
      // Disney Cruise Line
      "disney cruise": "Disney Cruise Line",
      "disney cruises": "Disney Cruise Line",
      "disney cruise line": "Disney Cruise Line",
      // Celebrity Cruises
      "celebrity": "Celebrity Cruises",
      "celebrity cruises": "Celebrity Cruises",
      // Virgin Voyages
      "virgin": "Virgin Voyages",
      "virgin voyages": "Virgin Voyages",
      "virgin cruise": "Virgin Voyages",
      // Holland America Line
      "holland": "Holland America Line",
      "holland america": "Holland America Line",
      "holland america line": "Holland America Line",
      // Princess
      "princess": "Princess",
      "princess cruises": "Princess",
      // Carnival
      "carnival": "Carnival",
      "carnival cruise": "Carnival",
      "carnival cruises": "Carnival",
      // MSC Cruises
      "msc": "MSC Cruises",
      "msc cruises": "MSC Cruises",
      // Viking Ocean
      "viking": "Viking Ocean",
      "viking ocean": "Viking Ocean",
      // American Cruise Line
      "american cruise": "American Cruise Line",
      "american cruise line": "American Cruise Line",
      // Atlas Ocean Voyages
      "atlas": "Atlas Ocean Voyages",
      "atlas ocean": "Atlas Ocean Voyages",
      "atlas ocean voyages": "Atlas Ocean Voyages",
      // Azamara
      "azamara": "Azamara",
      // Crystal Cruises
      "crystal": "Crystal Cruises",
      "crystal cruises": "Crystal Cruises",
      // Cunard
      "cunard": "Cunard",
      "cunard cruises": "Cunard",
      // Emerald Cruises
      "emerald": "Emerald Cruises",
      "emerald cruises": "Emerald Cruises",
      // Explora Journeys
      "explora": "Explora Journeys",
      "explora journeys": "Explora Journeys",
      // Four Seasons Yachts
      "four seasons": "Four Seasons Yachts",
      "four seasons yachts": "Four Seasons Yachts",
      "four seasons yacht": "Four Seasons Yachts",
      // Funjet
      "funjet": "Funjet",
      "fun jet": "Funjet",
      // Oceania Cruises
      "oceania": "Oceania Cruises",
      "oceania cruises": "Oceania Cruises",
      // Paul Gauguin Cruises
      "paul gauguin": "Paul Gauguin Cruises",
      "paul gauguin cruises": "Paul Gauguin Cruises",
      // Ponant
      "ponant": "Ponant",
      "ponant cruises": "Ponant",
      // Regent Seven Seas Cruises
      "regent": "Regent Seven Seas Cruises",
      "regent seven seas": "Regent Seven Seas Cruises",
      "seven seas": "Regent Seven Seas Cruises",
      // Ritz-Carlton Yacht Collection
      "ritz-carlton": "Ritz-Carlton Yacht Collection",
      "ritz carlton": "Ritz-Carlton Yacht Collection",
      "ritz-carlton yacht": "Ritz-Carlton Yacht Collection",
      // Seabourn
      "seabourn": "Seabourn",
      "seabourn cruises": "Seabourn",
      // Silversea
      "silversea": "Silversea",
      "silversea cruises": "Silversea",
      // Star Clippers
      "star clippers": "Star Clippers",
      "star clipper": "Star Clippers",
      // Tauck Cruises
      "tauck": "Tauck Cruises",
      "tauck cruises": "Tauck Cruises",
      // Windstar
      "windstar": "Windstar",
      // Viking River
      "viking river": "Viking River",
      "viking river cruises": "Viking River",
      // Avalon Waterways
      "avalon": "Avalon Waterways",
      "avalon waterways": "Avalon Waterways",
      // Ama Waterways
      "ama": "Ama Waterways",
      "ama waterways": "Ama Waterways",
      // CroisiEurope
      "croisieurope": "CroisiEurope",
      "croisi europe": "CroisiEurope",
      "croisi-europe": "CroisiEurope",
      // Riverside Cruises
      "riverside": "Riverside Cruises",
      "riverside cruises": "Riverside Cruises",
      // Riviera River Cruises
      "riviera": "Riviera River Cruises",
      "riviera river": "Riviera River Cruises",
      "riviera river cruises": "Riviera River Cruises",
      // Tauck Tours
      "tauck tours": "Tauck Tours",
      "tauck tour": "Tauck Tours",
      // Uniworld
      "uniworld": "Uniworld",
      "uniworld cruises": "Uniworld",
      // Scenic River
      "scenic river": "Scenic River",
      // Lindblad Expeditions & National Geographic
      "lindblad": "Lindblad Expeditions & National Geographic",
      "lindblad expeditions": "Lindblad Expeditions & National Geographic",
      "national geographic": "Lindblad Expeditions & National Geographic",
      // Hurtigruten
      "hurtigruten": "Hurtigruten",
      "hurtigruten cruises": "Hurtigruten",
      // Adventures by Disney
      "adventures by disney": "Adventures by Disney",
      // Disneyland
      "disneyland": "Disneyland",
      "disney land": "Disneyland",
      // DisneyWorld
      "disneyworld": "DisneyWorld",
      "disney world": "DisneyWorld",
      // Aulani, A Disney Resort & Spa
      "aulani": "Aulani, A Disney Resort & Spa",
      "a disney resort": "Aulani, A Disney Resort & Spa",
      "aulani, a disney resort & spa": "Aulani, A Disney Resort & Spa",
      // Sandals
      "sandals": "Sandals",
      // Beaches
      "beaches": "Beaches",
      // Breathless
      "breathless": "Breathless",
      // Club Med
      "club med": "Club Med",
      "clubmed": "Club Med",
      // El Dorado Spa Resorts & Hotels
      "el dorado": "El Dorado Spa Resorts & Hotels",
      "el dorado spa": "El Dorado Spa Resorts & Hotels",
      // Dreams
      "dreams": "Dreams",
      "dreams resorts": "Dreams",
      // Excellence Resorts
      "excellence": "Excellence Resorts",
      "excellence resorts": "Excellence Resorts",
      // Hard Rock Hotels
      "hard rock": "Hard Rock Hotels",
      "hard rock hotels": "Hard Rock Hotels",
      // Iberostar Hotels & Resorts
      "iberostar": "Iberostar Hotels & Resorts",
      "iberostar hotels": "Iberostar Hotels & Resorts",
      // Karisma Hotels & Resorts
      "karisma": "Karisma Hotels & Resorts",
      // Outrigger Hotels & Resorts
      "outrigger": "Outrigger Hotels & Resorts",
      "outrigger hotels": "Outrigger Hotels & Resorts",
      // Palace Resorts
      "palace": "Palace Resorts",
      "palace resorts": "Palace Resorts",
      // RIU Hotels & Resorts
      "riu": "RIU Hotels & Resorts",
      "riu hotels": "RIU Hotels & Resorts",
      // Secrets
      "secrets": "Secrets",
      // Delta Vacations
      "delta": "Delta Vacations",
      "delta vacations": "Delta Vacations",
      // Southwest Vacations
      "southwest": "Southwest Vacations",
      "southwest vacations": "Southwest Vacations",
      // United Vacations
      "united": "United Vacations",
      "united vacations": "United Vacations",
      // Villas of Distinction
      "villas": "Villas of Distinction",
      "villas of distinction": "Villas of Distinction",
      // Zo√´try Wellness & Spa Resorts
      "zo√´try": "Zo√´try Wellness & Spa Resorts",
      "zoeetry": "Zo√´try Wellness & Spa Resorts",
      // BlueSky Tours
      "bluesky": "BlueSky Tours",
      "blue sky tours": "BlueSky Tours",
      // CIE Tours
      "cie": "CIE Tours",
      "cie tours": "CIE Tours",
      // Collette
      "collette": "Collette",
      // Great Safaris
      "great safaris": "Great Safaris",
      // Project Expedition
      "project expedition": "Project Expedition",
      "project expeditions": "Project Expedition",
      // Shore Excursions Group
      "shore excursions": "Shore Excursions Group",
      "shore excursions group": "Shore Excursions Group",
      // TourSales.com
      "toursales": "TourSales.com",
      "tour sales": "TourSales.com",
      // Trafalgar
      "trafalgar": "Trafalgar"
    };

    // Returns canonical vendor name
    function getCanonicalVendor(vendor) {
      const vendorLower = vendor.trim().toLowerCase();
      if (aliasMapping[vendorLower]) {
        return aliasMapping[vendorLower];
      }
      for (const supplier of knownSuppliers) {
        if (supplier.toLowerCase() === vendorLower) {
          return supplier;
        }
      }
      return vendor;
    }

    // Parse HQ deals text into an array of objects { vendor, text, original }
    function parseHQDeals(text) {
      const lines = text.split('\n');
      const deals = [];
      let currentVendor = "";
      lines.forEach(line => {
        let trimmed = line.trim();
        if (!trimmed) return;
        if (trimmed.toLowerCase().startsWith("v")) {
          // Update current vendor using the canonical name.
          currentVendor = getCanonicalVendor(trimmed.substring(1).replace(":", "").trim());
        } else if (trimmed.toLowerCase().startsWith("d") || trimmed.toLowerCase().startsWith("ed")) {
          // Store the original line along with parsed deal text.
          let marker = trimmed.toLowerCase().startsWith("ed") ? "ed" : "d";
          let dealText = marker === "ed" ? trimmed.substring(2).trim() : trimmed.substring(1).trim();
          deals.push({
            vendor: currentVendor,
            text: dealText,
            original: trimmed // preserve the full original line (including "d" or "ed")
          });
        }
      });
      return deals;
    }

    // Parse JSON deals into an array of objects with needed fields.
    function parseJSONDeals(jsonText) {
      try {
        const jsonData = JSON.parse(jsonText);
        return jsonData.map(item => ({
          vendor: getCanonicalVendor(item.shopOverline || ""),
          expiryDate: item.expiryDate, // ISO string
          title: item.title || "",
          shopListing: item.shopListing || ""
        }));
      } catch (e) {
        alert("Invalid JSON input.");
        return [];
      }
    }

    // Extract all normalized dates from a string as YYYY-MM-DD (returns [{raw, display, ymd, Date obj}])
    function extractAllDatesWithInfo(text) {
      const dates = [];
      // ISO YYYY-MM-DD
      const isoRegex = /(\d{4})-(\d{2})-(\d{2})/g;
      let match;
      while ((match = isoRegex.exec(text)) !== null) {
        let ymd = `${match[1]}-${match[2]}-${match[3]}`;
        let dObj = new Date(ymd);
        if (!isNaN(dObj.getTime()))
          dates.push({raw: match[0], display: formatDate(dObj), ymd, dateObj: dObj});
      }
      // MM/DD/YY(YY) or MM-DD-YY(YY)
      const usRegex = /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})/g;
      while ((match = usRegex.exec(text)) !== null) {
        let year = match[3];
        if (year.length === 2) year = "20"+year;
        let dObj = new Date(`${match[1]}/${match[2]}/${year}`);
        if (!isNaN(dObj.getTime())) {
          let mm = String(match[1]).padStart(2,'0'), dd= String(match[2]).padStart(2,'0');
          let ymd = `${year}-${mm}-${dd}`;
          dates.push({raw: match[0], display: formatDate(dObj), ymd, dateObj: dObj});
        }
      }
      return dates;
    }

    // Choose last date (latest) out of parsed results
    function selectLatestDate(dates) {
      if (!dates.length) return null;
      return dates.reduce((latest, d) => (!latest||d.dateObj>latest.dateObj)?d:latest, null);
    }

    // Returns {ymd, dateObj, display, original} for the latest date found
    function extractNormalizedExpiry(text) {
      const dates = extractAllDatesWithInfo(text);
      const latest = selectLatestDate(dates);
      if (!latest) return null;
      return {
        ...latest
      };
    }

    // Normalize expiry from JSON ISO, return {ymd, dateObj, display, original}
    function normalizeJSONExpiry(dateStr) {
      if (!dateStr) return null;
      let dObj = new Date(dateStr);
      if (isNaN(dObj.getTime())) return null;
      let mm = String(dObj.getMonth()+1).padStart(2,'0');
      let dd = String(dObj.getDate()).padStart(2,'0');
      let year = dObj.getFullYear();
      let ymd = `${year}-${mm}-${dd}`;
      return {ymd, dateObj: dObj, display: formatDate(dObj), original: dateStr};
    }

    // Format a date for display (M/D/YYYY)
    function formatDate(dateObj) {
      if (!dateObj) return "N/A";
      const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      return `${months[dateObj.getMonth()]} ${dateObj.getDate()}, ${dateObj.getFullYear()}`;
    }

    // --- Synonym Dictionaries ---
    // For keyword normalization and scoring equivalence
    const keywordSynonyms = {
      // synonyms group: all lowercase
      "opaque": ["covert", "secret", "hidden"],
      "covert": ["opaque", "secret", "hidden"],
      "secret": ["opaque", "covert", "hidden"],
      "hidden": ["opaque", "covert", "secret"],

      "free": ["complimentary", "complementary", "compliment", "gratis"],
      "complimentary": ["free", "complementary", "compliment", "gratis"],
      "complementary": ["free", "complimentary", "compliment", "gratis"],  // typo-variant
      "compliment": ["free", "complimentary", "complementary", "gratis"],

      // half off equivalence group
      "half off": ["50% off", "50% reduced", "50% discount", "50 percent off", "50 percent reduced", "50 percent discount"],
      "50% off": ["half off", "50% reduced", "50% discount", "50 percent off", "50 percent reduced", "50 percent discount"],
      "50% reduced": ["half off", "50% off", "50% discount", "50 percent off", "50 percent reduced", "50 percent discount"],
      "50% discount": ["half off", "50% off", "50% reduced", "50 percent off", "50 percent reduced", "50 percent discount"],
      "50 percent off": ["half off", "50% off", "50% reduced", "50% discount", "50 percent reduced", "50 percent discount"],
      "50 percent discount": ["half off", "50% off", "50% reduced", "50% discount", "50 percent off", "50 percent reduced"],
      "50 percent reduced": ["half off", "50% off", "50% reduced", "50% discount", "50 percent off", "50 percent discount"],
    };

    // Words we treat as canonical, so "half off" is normalized same as "50% off"
    function normalizeKeyword(word) {
      const w = word.trim().toLowerCase();
      for (let canon in keywordSynonyms) {
        const set = [canon, ...keywordSynonyms[canon]];
        if (set.some(s => w === s)) return canon; // map to canonical
      }
      // try to recognize "50% off type" and normalize as "half off"
      if (
        /(^|[\s\-])50(\s*%|\s*percent)?\s*(reduced|discount|off)/.test(w)
        || w === "50%"
        || w === "50 percent"
      ) return "half off";
      if (["complimentary", "complementary", "gratis", "compliment"].includes(w)) return "free";
      return w;
    }

    // For matching, for any word, return synonyms (including itself)
    function synonymsFor(word) {
      const w = word.toLowerCase();
      if (keywordSynonyms[w]) {
        return [w, ...keywordSynonyms[w]].map(String);
      }
      // If we have a canonical for this, include only canonical
      const canon = normalizeKeyword(word);
      if (canon !== w) return [canon];
      return [w];
    }

    // --- Extract keywords with synonyms and proper normalization ---
    function extractNormalizedKeywords(text, {noExclusive=false} = {}) {
      let t = text.toLowerCase();

      // Synonym normalization rules for 2nd, 3rd etc as the prompt described
      Object.entries(specialWordReplacements).forEach(([k,v])=>{
        t = t.replace(new RegExp("\\b"+k+"\\b",'g'),v);
      });
      // 24/48 hour phrase always as key "24hour" etc.
      t = t.replace(/(24|48)[\s\-]?(hour|hr)[\s\-]?sale/gi, (m, n, unit) => `${n}${unit}sale`);
      t = t.replace(/(24|48)[\s\-]?(hour|hr)/gi, (m, n, unit)=>`${n}${unit}`);

      // Replace complimentary/complementary/compliment/gratis with "free" for normalization
      t = t.replace(/\b(complimentary|complementary|compliment|gratis)\b/g, "free");

      // Normalize "50% reduced"/"reduced by 50%" etc to "half off"
      t = t.replace(/(50\s*%|50\s*percent)\s*(off|reduced|discount)/g, "half off");
      t = t.replace(/half[\s\-]?off/g, "half off");

      // IMPORTANT: Remove monetary values before extracting keywords
      t = t.replace(/\$\s*\d{1,3}(,\d{3})*(\.\d+)?/g, ' ');
      
      // Remove percentage values that aren't part of specific phrases like "half off"
      // Don't remove the ones we already normalized
      if (!t.includes("half off")) {
        t = t.replace(/\d+\s*%/g, ' ');
        t = t.replace(/\d+\s*percent/gi, ' ');
      }

      // Remove punctuation except % and $
      t = t.replace(/[^a-z0-9\s]/g, ' ');

      // Extract all ngrams: (e.g. "half off" as one keyword too, in addition to "half" and "off")
      var words = t.split(/\s+/).filter(w=>w.length>1);
      var ngrams = [];
      for (let i=0;i<words.length;i++) {
        let single = words[i].trim();
        if (!single) continue;
        // Don't include "exclusive" (for matching exclusion detection, not as a keyword)
        if (noExclusive && single==="exclusive") continue;
        
        // Skip numeric values entirely - they should be handled by dedicated extractors
        if (/^\d+$/.test(single)) continue;
        
        ngrams.push(normalizeKeyword(single));
        // bi-grams (for things like "half off")
        if (i+1<words.length) {
          let bi = normalizeKeyword(words[i]+" "+words[i+1]);
          if (bi && bi!==ngrams[ngrams.length-1]) ngrams.push(bi);
        }
      }
      // Uniquify
      let out = [];
      let seen = {};
      for (let kw of ngrams) {
        if (!seen[kw] && kw.length > 1) {
          seen[kw] = 1;
          out.push(kw);
        }
      }
      // Remove "exclusive" only if requested
      if (noExclusive) out = out.filter(w=>w !== "exclusive");
      return out;
    }

    // --- Keyword set overlap using synonyms ---
    function keywordSetOverlap(arr1, arr2) {
      let set1 = arr1;
      let set2 = arr2;
      let usedIdx2 = new Set();
      let matches = [];
      for (let i = 0; i < set1.length; i++) {
        let kw = set1[i];
        let foundMatch = false;
        for (let j = 0; j < set2.length; j++) {
          if (usedIdx2.has(j)) continue;
          // synonym match
          const syn1 = synonymsFor(kw), syn2 = synonymsFor(set2[j]);
          if (syn1.some(x => syn2.includes(x))) {
            matches.push(syn1[0]);
            usedIdx2.add(j);
            foundMatch = true;
            break;
          }
        }
      }
      // Uniquify
      return [...new Set(matches)];
    }

    // --- Enhanced Percentage Matching ---
    // For percentage matching: recognize 10%, 10 %, 10percent/percent, ten percent, etc.
    function extractPercentageValues(text) {
      const vals = [];
      let match;
      // Numeric percent: 10%, 10 %
      const percentNum = /(\d+)\s*%/g;
      while ((match = percentNum.exec(text)) !== null) {
        vals.push(parseInt(match[1]));
      }
      // 10 percent (loose spacing)
      const percentWord = /(\d+)\s*percent/gi;
      while ((match = percentWord.exec(text)) !== null) {
        vals.push(parseInt(match[1]));
      }
      return vals;
    }

    // --- Enhanced Money Matching ---
    // normalize $1,000 as 1000, catch $ 1,000, $2000, etc.
    function extractMoneyValues(text) {
      const vals = [];
      let match;
      // $1,000, $ 1,000, $2000
      const moneyReg = /\$\s*(\d{1,3}(?:,\d{3})*|\d+)(\.\d+)?/g;
      while ((match = moneyReg.exec(text)) !== null) {
        // Extract the full number without the $ sign
        const fullMatch = match[0].substring(match[0].indexOf('$') + 1).trim();
        // Remove commas and convert to float
        const value = parseFloat(fullMatch.replace(/,/g, ""));
        vals.push(value);
      }
      return vals;
    }

    // --- Synonym Match Helper ---
    // Determines whether, given two arrays, any synonym from either appears in the other
    function arrHasSynonym(arr1, arr2) {
      for (let kw of arr1) {
        for (let kw2 of arr2) {
          if (synonymsFor(kw).some(s => synonymsFor(kw2).includes(s))) {
            return true;
          }
        }
      }
      return false;
    }

    // --- Opaque deal detection for synonym match ---
    function hasOpaqueSynonym(text1, text2) {
      // If either includes ["opaque", "covert", "secret", "hidden"], they should match so long as synonym is present
      const opaqueSet = ["opaque", "covert", "secret", "hidden"];
      let t1 = text1.toLowerCase(), t2 = text2.toLowerCase();
      return opaqueSet.some(word =>
        t1.includes(word) && opaqueSet.some(w2 => t2.includes(w2))
      );
    }

    // --- Half-off detection via synonyms/percentages ---
    function isHalfOffDeal(text) {
      const t = text.toLowerCase();
      // 50 percent off/reduced/discount
      if (/(50\s*%|50\s*percent)\s*(off|reduced|discount)/.test(t)) return true;
      if (t.includes("half off")) return true;
      return false;
    }

    // --- Updated Has Functions for Features/Synonyms ---
    function hasGratuity(text) {
      const lower = text.toLowerCase();
      const gratuityTerms = [
        "pre paid gratuities", "pre-paid gratuities", "prepaid gratuities",
        "free gratuities", "free grat", "gratuities", "ppg"
      ];
      return gratuityTerms.some(term => lower.includes(term));
    }
    function hasOBC(text) {
      const lower = text.toLowerCase();
      const obcTerms = ["onboard credit", "on board credit", "obc", "on-board credit"];
      return obcTerms.some(term => lower.includes(term));
    }
    function hasKids(text) {
      const lower = text.toLowerCase();
      const kidTerms = [" kid ", " kids ", " child ", " children ", "3rd guest", "third guest", "4th guest", "fourth guest"];
      return kidTerms.some(term => lower.includes(term)) || /\b(kid|kids|child|children)\b/.test(lower);
    }

    // ---- NEW: Special Numeric Phrase Extraction ----
    // Recognize phrases like "for 2", "for two", "buy 2 get 1", but avoid "2nd" (means 'second', not a number value)
    // Returns all special relevant numbers, e.g. [2,1]
    function extractSpecialNumericAll(text) {
      const out = [];
      // Ignore '2nd' or '3rd', they are ordinal markers (e.g., "2nd guest" is not "for 2")
      const ignoreWords = /\b(\d{1,2})(st|nd|rd|th)\b/gi;
      text = text.replace(ignoreWords, ''); // Remove ordinal markers from text

      // "for 2", "for two", etc.
      let match;
      const forNumRegex = /for\s+(two|three|four|five|six|seven|eight|nine|\d+)/gi;
      const wordToNumber = {
        "two": 2, "three": 3, "four": 4, "five": 5, "six": 6,
        "seven": 7, "eight": 8, "nine": 9
      };
      while((match = forNumRegex.exec(text)) !== null) {
        let val = match[1];
        if (wordToNumber[val.toLowerCase()]) val = wordToNumber[val.toLowerCase()];
        out.push(Number(val));
      }

      // "buy X get Y"
      const buyGetRegex = /buy\s+(\d+)\s+get\s+(\d+)/gi;
      while((match = buyGetRegex.exec(text)) !== null) {
        out.push(Number(match[1]), Number(match[2]));
      }

      // "x for $y" style
      const xForYRegex = /(\d+)\s*for\s*[$]?\s*(\d+)/gi;
      while((match = xForYRegex.exec(text)) !== null) {
        out.push(Number(match[1]), Number(match[2]));
      }

      // Uniquify and sort
      return [...new Set(out)].sort((a,b)=>a-b);
    }

    // --- EXCLUSIVE HIGHLIGHT LOGIC ---
    function exclusiveFlag(hqText, jsText) {
      let hqHas = /\bexclusive\b/i.test(hqText);
      let jsHas = /\bexclusive\b/i.test(jsText);
      return jsHas && !hqHas;
    }

    // --- SPECIAL REPLACEMENT for 2nd = second and handling 24/48 hour sales ---
    // Map for normalization
    const specialWordReplacements = {
      "2nd": "second",
      "3rd": "third",
      "4th": "fourth",
      "1st": "first",
      "nd": "",
      "rd": "",
      "th": "",
      "st": "",
    };

    // --- Main ENHANCED MATCHING LOGIC ---
    function compareDealScore(hqDeal, jsonDeal) {
      // 0. Vendor check prerequisite (no score!)
      if (hqDeal.vendor !== jsonDeal.vendor) {
        return {score: 0, reasons: ["Vendor mismatch"], flags: {}};
      }
      let reasons = [];
      let score = 0;
      let flags = {};
      reasons.push(`Vendor: ${hqDeal.vendor} (required)`);

      // --- Normalize main values ---
      const jsAllText = `${jsonDeal.title} ${jsonDeal.shopListing}`.trim();

      // Date normalization
      const hqExp = extractNormalizedExpiry(hqDeal.text);
      const jsExp = normalizeJSONExpiry(jsonDeal.expiryDate);

      // Money & percent (EXACT sets)
      let hqPerc = extractPercentageValues(hqDeal.text);
      let jsPerc = extractPercentageValues(jsAllText);
      let hqMoney = extractMoneyValues(hqDeal.text);
      let jsMoney = extractMoneyValues(jsAllText);
      let hqSpecials = extractSpecialNumericAll(hqDeal.text);
      let jsSpecials = extractSpecialNumericAll(jsAllText);

      // For scoring, these must match in value & count (order-insensitive)
      function arraysEqual(a,b) {
        if (a.length!==b.length) return false;
        let aSorted= a.slice().sort(), bSorted= b.slice().sort();
        for (let i=0;i<aSorted.length;i++) if (aSorted[i]!==bSorted[i]) return false;
        return true;
      }

      let percentMatch = false, moneyMatch = false, specialMatch = false, nSynergy = false;

      // Special Numeric match, like for 2, etc.
      if (hqSpecials.length || jsSpecials.length){
        if (arraysEqual(hqSpecials,jsSpecials)) {
          score += 60; specialMatch = true;
          reasons.push('Special numeric phrase match: '+hqSpecials.join(', ')+ ' (+60)');
        }
      }
      // Percent match, robust: "10%", "10 %", "10 percent" (handled in extraction)
      if (hqPerc.length || jsPerc.length) {
        if (arraysEqual(hqPerc,jsPerc)) {
          score += 60; percentMatch = true;
          reasons.push('Percentage value match: '+hqPerc.join('%, ')+ '% (+60)');
        } else if (hqPerc.length && jsPerc.length) {
          reasons.push('Percentage mismatch');
        }
      }
      // Money match: exact, robust handling of $1,000 etc.
      if (hqMoney.length || jsMoney.length) {
        if (arraysEqual(hqMoney.map(x=>x.toFixed(2)), jsMoney.map(x=>x.toFixed(2)))) {
          score += 60; moneyMatch = true;
          reasons.push('Money match: $'+hqMoney.join(', $')+' (+60)');
        } else if (hqMoney.length && jsMoney.length) {
          reasons.push('Money value mismatch');
        }
      }

      // Explicit synonym matches for "half off"/"50% off", etc.
      let hqHalfOff = isHalfOffDeal(hqDeal.text) || false;
      let jsHalfOff = isHalfOffDeal(jsAllText) || false;
      if (hqHalfOff && jsHalfOff) {
        score += 60;
        percentMatch = true; // This is an equivalence match!
        reasons.push('"Half off" (50% off) match (+60)');
      }

      // Opaque/Cover/Secret/Hidden match: must be synonyms in both places
      let hqOpaque = /opaque|covert|secret|hidden/i.test(hqDeal.text);
      let jsOpaque = /opaque|covert|secret|hidden/i.test(jsAllText);
      if (hqOpaque && jsOpaque && hasOpaqueSynonym(hqDeal.text, jsAllText)) {
        score += 40;
        reasons.push('Opaque/Cover/Secret/Hidden (synonym group) present on both sides (+40)');
      }

      // Keyword matching, using synonym grouping, excluding "exclusive"
      let kwsHQ = extractNormalizedKeywords(hqDeal.text, {noExclusive:true});
      let kwsJS = extractNormalizedKeywords(jsAllText, {noExclusive:true});
      // This ensures e.g. "free" matches "complementary", "half off" matches "50% off"
      let commonKWSyn = keywordSetOverlap(kwsHQ, kwsJS);
      if (commonKWSyn.length>=1) {
        let perKw = 15;
        score += perKw * commonKWSyn.length;
        reasons.push(
          `${commonKWSyn.length} keyword${commonKWSyn.length>1?"s":""} match (${commonKWSyn.map(w=>`<span class="keyword-flag">${w}</span>`).join(" ")}, +${perKw*commonKWSyn.length})`
        );
      }

      // 24/48 hour sale phrase as non-number keyword
      const kw24hHQ = /\b(24|48)[\s\-]?(hour|hr)\b/i.test(hqDeal.text);
      const kw24hJS = /\b(24|48)[\s\-]?(hour|hr)\b/i.test(jsAllText);
      if (kw24hHQ && kw24hJS) {
        score += 16;
        reasons.push('Matched "24/48 hour" sale keyword (+16)');
      }

      // Synergy: Any numeric value (money or percent) + any keyword match = +25 (slight boost)
      if ((percentMatch||moneyMatch) && commonKWSyn.length>=1) {
        nSynergy = true;
        score += 25;
        reasons.push('<span class="orange" style="color:orange;font-weight:bold;">Synergy bonus: numeric/value + keyword (+25)</span>');
      }

      // Date logic
      let matchedDate = false, dateFlag = false, dateDiffDays = null;
      let dateInfo = "";
      if (hqExp && jsExp) {
        let diff = Math.abs(hqExp.dateObj - jsExp.dateObj) / (1000*60*60*24);
        diff = Math.round(diff);
        dateDiffDays = diff;
        if (hqExp.ymd === jsExp.ymd) {
          score += 50; matchedDate = true;
          dateInfo = 'Exact date match: '+hqExp.display+ ' (+50)';
        } else if (diff <= 5) {
          score += 22; matchedDate = true; dateFlag = true;
          flags.dateFlag = true;
          dateInfo = `Date within 5 days (${hqExp.display} vs ${jsExp.display}, +22)`;
          reasons.push('<strong class="orange">‚ö†Ô∏è Date mismatch (within 5 days)</strong>');
        } else {
          dateInfo = `Date mismatch: ${hqExp.display} (HQ) vs ${jsExp.display} (JSON)`;
          reasons.push('<strong class="orange">‚ö†Ô∏è Date mismatch</strong>');
          dateFlag = true;
          flags.dateFlag = true;
        }
        reasons.push(dateInfo);
      }

      // Bonus: if we have BOTH exact monetary/percentage match AND exact date AND at least 1 matched keyword
      if ((percentMatch||moneyMatch) && hqExp && jsExp && hqExp.ymd===jsExp.ymd && commonKWSyn.length) {
        score += 60;
        reasons.push('<b style="color:orange">Synergy: value/date/keyword all match! (+60)</b>');
        flags.highConfidence = true;
      }

      // Check for gratuity, OBC, kids (fully synonym-matched as-is)
      let hqGrat = hasGratuity(hqDeal.text);
      let jsGrat = hasGratuity(jsAllText);
      if (hqGrat && jsGrat) { score += 35; reasons.push("Gratuities present (+35)"); }
      else if (hqGrat || jsGrat) {
        reasons.push("Gratuity mention only on one side (-15)");
        score -= 15;
      }
      let hqOBC = hasOBC(hqDeal.text);
      let jsOBC = hasOBC(jsAllText);
      if (hqOBC && jsOBC) { score += 35; reasons.push("OBC present (+35)"); }
      else if (hqOBC || jsOBC) { reasons.push("OBC mention only on one side (-15)"); score -= 15; }
      let hqKids = hasKids(hqDeal.text);
      let jsKids = hasKids(jsAllText);
      if (hqKids && jsKids) { score += 35; reasons.push("Kids/child present (+35)"); }
      else if (hqKids || jsKids) { reasons.push("Kids/child only on one side (-10)"); score -= 10; }

      // *** "exclusive" handling: NOT a keyword, but flag if JSON has it but HQ doesn't ***
      flags.exclusiveFlag = exclusiveFlag(hqDeal.text, jsAllText);

      // Bounded score
      score = Math.max(0, Math.min(score, 510));
      return {
        score, reasons, flags,
        hqExp, jsExp,
        commonKW: commonKWSyn,
        nSynergy, percentMatch, moneyMatch, dateFlag, dateDiffDays
      };
    }

    // --- Rendering tweaks for new flags ---
    function renderMatchedDeals() {
      const container = document.getElementById("matchedDealsContainer");
      const filter = document.getElementById("matchedFilter")?.value?.trim() ?? "";
      const filteredDeals = filterDeals(matchedDeals, filter);

      // Sort filteredDeals by score from lowest to highest
      filteredDeals.sort((a, b) => a.score - b.score);

      container.innerHTML = "";
      document.getElementById("matchedCount").textContent = matchedDeals.length;

      if (filteredDeals.length === 0) {
        container.innerHTML = "<div class='no-matches'>No matched deals found.</div>";
        return;
      }

      filteredDeals.forEach((matchObj, index) => {
        const match = matchObj;
        const row = document.createElement("div");

        // Get additional matching info for flag rendering by rerunning score
        const matchRes = match.jsonDeal
          ? compareDealScore(match.hqDeal, match.jsonDeal)
          : {flags:{}, hqExp:null,jsExp:null};

        // Highlight container if it's a possible date change
        if (matchRes.dateFlag) row.className = "matched-deal possible-date-change";
        else row.className = "matched-deal";

        // Score badge
        const scoreDiv = document.createElement("div");
        scoreDiv.className = "match-score";
        scoreDiv.textContent = match.score;
        scoreDiv.title = "Match score";

        // --- HQ column ---
        const leftCol = document.createElement("div");
        leftCol.className = "deal-info";

        // Keyword synergy flag
        if (matchRes.nSynergy && matchRes.percentMatch||matchRes.moneyMatch) {
          const div = document.createElement("span");
          div.className="date-flag"; div.textContent = "SYNERGY";
          leftCol.appendChild(div);
        }
        // Date change flag
        if (matchRes.dateFlag) {
          const div = document.createElement("span");
          div.className="date-flag";
          div.textContent =
            matchRes.dateDiffDays && matchRes.dateDiffDays<=5
            ?  "POSSIBLE DATE CHANGE"
            : "DATE MISMATCH";
          leftCol.appendChild(div);
        }

        // Exclusive flag highlight
        if (matchRes.flags.exclusiveFlag) {
          const div = document.createElement("span");
          div.className="exclusive-flag";
          div.textContent = "Exclusive listed on JSON";
          leftCol.appendChild(div);
        }

        // Vendor
        const vendorSpan = document.createElement("span");
        vendorSpan.className = "deal-vendor";
        vendorSpan.textContent = match.hqDeal.vendor;
        leftCol.appendChild(vendorSpan);
        leftCol.appendChild(document.createTextNode(": "));

        // HQ deal text
        // Replace all dates with normalized, original display, flag mismatch in orange if dateFlag
        let base = match.hqDeal.text;

        // Build a map: {rawDateString: {display,raw,ymd,dateObj}}
        const allDates = extractAllDatesWithInfo(base);
        let dateFinals = {};
        allDates.forEach(d=>{
          dateFinals[d.raw]=d;
        });

        // Replace each date with normalized + original and orange if it's the main expiry date (compared)
        let rendered = base.replace(/(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}|\d{4}-\d{2}-\d{2})/g, (m) => {
          const info = dateFinals[m];
          if (!info) return m;
          if (matchRes.dateFlag && matchRes.hqExp && info.ymd===matchRes.hqExp.ymd) {
            // It's main expiry: flag orange for mismatch/change
            return `<span class="hq-date-mismatch">${info.display}<br><small>(${info.raw})</small></span>`;
          } else {
            return `<span class="expiry-date">${info.display}<br><small style="color:#aaa;">(${info.raw})</small></span>`;
          }
        });
        // Show matched keywords inline as .keyword-flag for fun
        (matchRes.commonKW||[]).forEach(kw=>{
          rendered = rendered.replace(new RegExp(`\\b(${kw})\\b`,'gi'),
            `<span class="keyword-flag">$1</span>`);
        });
        // Money highlight
        rendered = rendered.replace(/(\$\s*\d{1,3}(?:,\d{3})*(?:\.\d+)?|\$\s*\d+(?:\.\d+)?)/g, 
            '<span class="price-value">$1</span>');
        // Percentages
        rendered = rendered.replace(/(\d+\s*%|\d+\s*percent)/gi, 
            '<span class="percentage-value">$1</span>');
        leftCol.innerHTML += rendered;

        // --- JSON column ---
        const rightCol = document.createElement("div");
        rightCol.className = "json-match";
        if (match.jsonDeal) {
          const jsonDetails = document.createElement("div");
          jsonDetails.innerHTML =
            `<strong>Vendor:</strong> ${match.jsonDeal.vendor}<br>` +
            `<strong>Expiry:</strong> <span class="expiry-date">${match.jsonDeal.expiryDate ? formatDate(new Date(match.jsonDeal.expiryDate)):"N/A"}</span><br>` +
            `<strong>Title:</strong> ${highlightTextJSON(match.jsonDeal.title)}<br>` +
            `<strong>Listing:</strong> ${highlightTextJSON(match.jsonDeal.shopListing)}`;
          if (matchRes.flags.exclusiveFlag)
            jsonDetails.innerHTML += `<div style="margin-top:4px;"><span class="exclusive-flag">EXCLUSIVE</span><span style="font-size:0.93em;">Present in JSON only</span></div>`;
          rightCol.appendChild(jsonDetails);
        } else {
          rightCol.textContent = "No JSON match details.";
        }

        // Match reasons tooltip
        const tooltip = document.createElement("div");
        tooltip.className = "tooltip";
        tooltip.innerHTML = "üëÅÔ∏è";
        const tooltipText = document.createElement("span");
        tooltipText.className = "tooltiptext";
        tooltipText.innerHTML = match.reasons
          ? match.reasons.join("<br>")
          : "[No match reasons available]";
        tooltip.appendChild(tooltipText);

        // Move to non-matched button
        const btn = document.createElement("button");
        btn.innerHTML = "üëé";
        btn.title = "Move to non-matched";
        btn.addEventListener("click", function() {
          matchedDeals.splice(matchedDeals.indexOf(match), 1);
          nonMatchedDeals.push(match.hqDeal);
          renderAll();
        });

        row.appendChild(scoreDiv);
        row.appendChild(leftCol);
        row.appendChild(rightCol);
        row.appendChild(tooltip);
        row.appendChild(btn);

        container.appendChild(row);
      });
    }

    // Global arrays
    let matchedDeals = []; // Array of { hqDeal, jsonDeal, score, jsonIndex, reasons }
    let nonMatchedDeals = []; // Array of HQ deals

    // Highlight numeric values and dates in text
    function highlightText(text) {
      // First escape HTML
      let result = text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
      
      // Highlight dates MM/DD/YYYY or YYYY-MM-DD
      result = result.replace(/(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}|\d{4}-\d{2}-\d{2})/g, 
        '<span class="expiry-date">$1</span>');
      
      // Highlight money values
      result = result.replace(/(\$\s*\d+(?:,\d{3})*(?:\.\d+)?|\$\s*\d+(?:\.\d+)?)/g, 
        '<span class="price-value">$1</span>');
      
      // Highlight percentages
      result = result.replace(/(\d+%)/g, 
        '<span class="percentage-value">$1</span>');
      
      return result;
    }
    
    // Use highlightText for JSON deals, but we do not normalize JSON dates
    function highlightTextJSON(text) {
      let result = text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
      // Dates
      const dateRegex = /(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}|\d{4}-\d{2}-\d{2})/g;
      result = result.replace(dateRegex, '<span class="expiry-date">$1</span>');
      // Money values
      result = result.replace(/(\$\s*\d{1,3}(?:,\d{3})*(?:\.\d+)?|\$\s*\d+(?:\.\d+)?)/g,
        '<span class="price-value">$1</span>');
      // Percentages
      result = result.replace(/(\d+\s*%|\d+\s*percent)/gi,
        '<span class="percentage-value">$1</span>');
      return result;
    }

    function filterDeals(deals, searchText) {
      if (!searchText) return deals;
      
      const terms = searchText.toLowerCase().split(/\s+/);
      return deals.filter(deal => {
        const text = (deal.hqDeal.vendor + " " + deal.hqDeal.text).toLowerCase();
        return terms.every(term => text.includes(term));
      });
    }
    
    function filterNonMatched(deals, searchText) {
      if (!searchText) return deals;
      
      const terms = searchText.toLowerCase().split(/\s+/);
      return deals.filter(deal => {
        const text = (deal.vendor + " " + deal.text).toLowerCase();
        return terms.every(term => text.includes(term));
      });
    }
    
    // Rendering functions
    function renderNonMatchedDeals() {
      const container = document.getElementById("nonMatchedDealsContainer");
      const filter = document.getElementById("nonMatchedFilter").value.trim();
      const filteredDeals = filterNonMatched(nonMatchedDeals, filter);

      container.innerHTML = "";
      document.getElementById("nonMatchedCount").textContent = nonMatchedDeals.length;

      if (filteredDeals.length === 0) {
        container.innerHTML = "<div class='no-matches'>No non-matched deals found.</div>";
        return;
      }

      filteredDeals.forEach((deal, index) => {
        const row = document.createElement("div");
        row.className = "non-matched-deal";

        // -- Find the nearest (best) jsonDeal for this deal --
        const nearest = findClosestMatch(deal, _lastJSONDeals, _lastThreshold);

        const info = document.createElement("div");
        info.className = "deal-info";

        const vendorSpan = document.createElement("span");
        vendorSpan.className = "deal-vendor";
        vendorSpan.textContent = deal.vendor;

        info.appendChild(vendorSpan);
        info.appendChild(document.createTextNode(": "));

        const dealTextSpan = document.createElement("span");
        dealTextSpan.innerHTML = highlightText(deal.text);
        info.appendChild(dealTextSpan);

        // --- Tooltip for nearest match, if found ---
        if (nearest) {
          const tooltip = document.createElement("div");
          tooltip.className = "tooltip";
          tooltip.innerHTML = "üëÅÔ∏è";
          const tooltipText = document.createElement("span");
          tooltipText.className = "tooltiptext";
          let reasonText = "";
          if (nearest.reasons && nearest.reasons.length) {
            reasonText =
              `<strong>Best Possible Match (Score: ${nearest.score}):</strong><br>` +
              `<span style="color:#3498db"><b>Vendor:</b> ${nearest.jsonDeal.vendor}</span><br>` +
              (nearest.jsonDeal.expiryDate
                ? `<b>Expiry:</b> <span class="expiry-date">${formatDate(new Date(nearest.jsonDeal.expiryDate))}</span><br>`
                : "") +
              `<b>Title:</b> ${highlightTextJSON(nearest.jsonDeal.title)}<br>` +
              `<b>Listing:</b> ${highlightTextJSON(nearest.jsonDeal.shopListing)}<br>` +
              `<hr style="border:none;border-top:1px solid #eee;margin:5px 0;">` +
              nearest.reasons.map(r=>`‚Ä¢ ${r}`).join("<br>");
          } else {
            reasonText = "No near-match info.";
          }
          tooltipText.innerHTML = reasonText;
          tooltip.appendChild(tooltipText);
          info.appendChild(tooltip);
        }

        const btn = document.createElement("button");
        btn.innerHTML = "üëç";
        btn.title = "Move to matched";
        btn.addEventListener("click", function() {
          nonMatchedDeals.splice(nonMatchedDeals.indexOf(deal), 1);
          matchedDeals.push({
            hqDeal: deal,
            jsonDeal: null,
            score: 0,
            jsonIndex: null,
            reasons: ["Manually matched"]
          });
          renderAll();
        });

        row.appendChild(info);
        row.appendChild(btn);
        container.appendChild(row);
      });
    }

    function renderAll() {
      renderMatchedDeals();
      renderNonMatchedDeals();
    }
    
    // Copy non-matched deals to clipboard in the original format
    function copyNonMatchedToClipboard() {
      // Group by vendor
      const groups = {};
      nonMatchedDeals.forEach(deal => {
        if (!groups[deal.vendor]) {
          groups[deal.vendor] = [];
        }
        groups[deal.vendor].push(deal.original);
      });
      
      let output = "";
      for (const vendor in groups) {
        output += "v\t" + vendor + ":\n";
        groups[vendor].forEach(dealLine => {
          output += dealLine + "\n";
        });
      }
      
      navigator.clipboard.writeText(output).then(() => {
        alert("Non-matched deals copied to clipboard!");
      }, () => {
        alert("Failed to copy to clipboard.");
      });
    }
    
    // Event listeners
    document.getElementById("compareButton").addEventListener("click", function() {
      const hqText = document.getElementById("hqDeals").value;
      const jsonText = document.getElementById("jsonDeals").value;
      const threshold = parseInt(document.getElementById("matchThreshold").value);
      
      const hqDeals = parseHQDeals(hqText);
      const jsonDeals = parseJSONDeals(jsonText);
      
      matchedDeals = [];
      nonMatchedDeals = [];
      
      const result = performMatching(hqDeals, jsonDeals, threshold);
      matchedDeals = result.matched;
      nonMatchedDeals = result.nonMatched;
      
      renderAll();
    });
    
    document.getElementById("copyButton").addEventListener("click", copyNonMatchedToClipboard);
    
    document.getElementById("matchedFilter").addEventListener("input", renderMatchedDeals);
    document.getElementById("nonMatchedFilter").addEventListener("input", renderNonMatchedDeals);

    let _lastHQDeals = [], _lastJSONDeals = [], _lastThreshold = 150;

    function performMatching(hqDeals, jsonDeals, threshold) {
      _lastHQDeals = hqDeals;
      _lastJSONDeals = jsonDeals;
      _lastThreshold = threshold;

      const candidateMatches = []; // { hqDeal, jsonDeal, score, jsonIndex, reasons }
      const nonMatched = [];

      hqDeals.forEach(hqDeal => {
        let bestScore = 0;
        let bestCandidate = null;
        let bestJsonIndex = null;
        let bestReasons = [];
        jsonDeals.forEach((jsonDeal, j) => {
          const { score, reasons } = compareDealScore(hqDeal, jsonDeal);
          if (score > bestScore) {
            bestScore = score;
            bestCandidate = jsonDeal;
            bestJsonIndex = j;
            bestReasons = reasons;
          }
        });
        if (bestScore >= threshold) {
          candidateMatches.push({
            hqDeal: hqDeal,
            jsonDeal: bestCandidate,
            score: bestScore,
            jsonIndex: bestJsonIndex,
            reasons: bestReasons
          });
        } else {
          nonMatched.push(hqDeal);
        }
      });

      // Enforce unique assignment with highest scores
      const uniqueMatches = {};
      candidateMatches.forEach(candidate => {
        const idx = candidate.jsonIndex;
        if (!uniqueMatches.hasOwnProperty(idx) || candidate.score > uniqueMatches[idx].score) {
          uniqueMatches[idx] = candidate;
        }
      });

      candidateMatches.forEach(candidate => {
        if (uniqueMatches[candidate.jsonIndex] !== candidate) {
          nonMatched.push(candidate.hqDeal);
        }
      });

      const matched = Object.values(uniqueMatches);
      return {
        matched,
        nonMatched
      };
    }

    function findClosestMatch(hqDeal, jsonDeals, minThreshold) {
      let bestScore = 0;
      let bestCandidate = null;
      let bestJsonIndex = null;
      let bestReasons = [];
      jsonDeals.forEach((jsonDeal, j) => {
        const { score, reasons } = compareDealScore(hqDeal, jsonDeal);
        if (score > bestScore) {
          bestScore = score;
          bestCandidate = jsonDeal;
          bestJsonIndex = j;
          bestReasons = reasons;
        }
      });
      if (bestScore > 0 && bestScore < minThreshold) {
        return {
          jsonDeal: bestCandidate,
          score: bestScore,
          reasons: bestReasons
        };
      }
      return null;
    }

    function hasGratuity(text) {
      const lower = text.toLowerCase();
      const gratuityTerms = [
        "pre paid gratuities", "pre-paid gratuities", "prepaid gratuities",
        "free gratuities", "free grat", "gratuities", "ppg"
      ];
      return gratuityTerms.some(term => lower.includes(term));
    }

    function hasOBC(text) {
      const lower = text.toLowerCase();
      const obcTerms = ["onboard credit", "on board credit", "obc", "on-board credit"];
      return obcTerms.some(term => lower.includes(term));
    }

    function hasKids(text) {
      const lower = text.toLowerCase();
      const kidTerms = [" kid ", " kids ", " child ", " children ", "3rd guest", "third guest", "4th guest", "fourth guest"];
      return kidTerms.some(term => lower.includes(term)) || /\b(kid|kids|child|children)\b/.test(lower);
    }
  </script>
</body>

</html>
